---
title: JS学习小记（三）
date: 2017-05-15 12:45:04
tags: JS
---
#### return 后面换行的问题
这是在一个 JS 的面试题里看到的，觉得应该注意一下，先看下面的两个函数：
```
function fool(){
	return{
		bar:"hello"
	};
}
```
```
function foo2(){
	return
    {
		bar:"hello"
	};
}
```
<!--more-->
这两个函数好像没什么不一样的地方，除了 return 后面的花括号一个是在同一行上，一个换行了。根据以往的编程经验，这种无所谓的事情到了 JS 中就要注意一下了，分别调用两个函数的结果如下:

![](http://i2.muimg.com/1949/b66d297264c067b7.png)

为什么 return 后面换行之后就是 **Undefined** 了呢？

一般编程语言的`;`是起到将两个语句分隔的作用，在 JS 中，只要一个语句自己独占一行的话，后面不用写`;`编译也不会有问题的，解析器会根据换行来判断两个语句是否独立。因此当使用到` return`、`break`、`continue`等语句后面换行时，解析器就误以为在这一行已经结束了，相当于：
```
function foo2(){
	return;
    {
		bar:"hello"
	};
}
```
所以就返回了个 undefined.

我平时的习惯都是后面紧跟花括号的哈哈，喜欢直接换行的朋友要注意一下了，不然发生错误的话我还真猜不到居然是这里出错了。

#### let 和 const
let 是什么？
let 是更完美的 var

到这里，我们明白了 let 是声明变量的另一种方法。但明明已经有 var 了，为什么还要用 let 呢？这要从 JavaScript 在设计之初引起的一些错误特性说起...这里不提，let 是为了弥补 var 的不足而诞生的，如我之前说的** var 没有块级作用域，而 let 有**；let 声明的全局变量不再是全局对象的属性了**，而是存在于全局对象之外的一个不可见的作用域中，真正意义上的全局；用 let 重定义的时候会报错**，所以 let 好像比较适合与严格模式；**let 声明的变量直到控制流到达该变量被定义的代码行时才会被装载**，这意味着在这之前调用 let 声明的变量的话就会报错，很严谨，跟 var 不一样。

感觉 var 用多了会变得越来越不严谨哈哈，这对编程来说可不好。

那么 const 有是什么？

const 和 let 是同一时期的产物，基本功能一样，唯一的区别就是，const 必须在声明时赋值，只声明不赋值是会报错的，而且声明赋值后，重新给它赋值也是会报错的。感觉 const 更像传统意义上的全局变量啊。

为了迎合 ES6，以后还是多用 let 吧，大势所趋。

#### 0.1 + 0.2 ！= 0.3？
又来一个 JS 奇葩的特性，当执行下面的语句时：
```
console.log(0.1 + 0.2 == 0.3);
```
结果是莫名其妙的 **false**。就好像有人告诉我 1+1 不是等于 2 一样，一脸懵逼。

再输出 0.1 + 0.2 看看结果是什么

![](http://i2.muimg.com/1949/40288c64df4969ca.png)

看到这串怪异的数字就意识到事情并不简单，JS 中的 Number类型是浮点型来的，而且是二进制的浮点型，其运算过程是，先将 0.1 和 0.2 转换为二进制浮点数进行运算，再将结果转换成十进制输出。二进制浮点数并不能精确表示类似 0.1 这样的数字，所以会有舍入误差。

那么解决方法是：
```
function add(num1,num2){
	let r1,r2,m;
	r1 = ('' + num1).split('.')[1].length;
	r2 = ('' + num2).split('.')[1].length;
	m = Math.pow(10,Math.max(r1,r2));
	return (num1 * m + num2 * m) / m;
}
```
先升幂再降幂

Happy Hacking!