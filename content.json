[{"title":"Angular2 Cannot find name '$'问题","date":"2017-07-26T12:54:25.000Z","path":"2017/07/26/Angular2-Cannot-find-name-问题/","text":"边做项目边学着 AngularJS ，MVC 模式，双向数据绑定等特性用着觉得很新鲜很舒服。然后突然网上看到 Angular2 的出现，继承了 Angular1.x 和 react.js 的优点，更方便快捷的开发体验。更重要的是它不是 Angular1.x 的延伸，而是全新的重写，新的概念和使用方法。犹豫了几秒，决定改战 Angular2….. 搭建好开发环境后，在引入 jquery 和 bootstrap 第三方插件的时候遇到一个问题，使用 JQuery 语法编译的时候显示 Cannot find name ‘$’ 。无法识别这个符号，估计是没有引用到 JQuery 的原因，但我检查了一下那些配置确定正确无误了。 后来在 stack overflow 上找到了解决方法：在 app.module.ts 中使用：1import * as $ from &apos;jquery&apos;; 引入 JQuery，很多人不需要这句也能正常编译，虽然我也不知道具体原因是什么，但这方法确实解决了我的问题 参考链接：Cannot find name ‘jquery’ in angular2","tags":[{"name":"Angular2","slug":"Angular2","permalink":"http://famousczm.github.io/tags/Angular2/"}]},{"title":"AngularJS ui-validate的使用","date":"2017-07-23T12:02:22.000Z","path":"2017/07/23/AngularJS-ui-validate的使用/","text":"今天在做项目的时候要用到自定义表单验证，于是用到了 AngularUI 的 ui-validate插件，遇到了一些问题，解决之后写下这篇博客抒发心中的苦笑不得。 先下载 ui-validate 然后导入到 html 中。在 js 里用angular.module(&#39;myApp&#39;, [&#39;ui.validate&#39;]);引入，然后就可以愉快地使用 ui-validate指令来自定义表单验证了。 举个栗子： 验证电话号码是否正确123456&lt;input type=&quot;text&quot; name=&quot;phoneNumber&quot; ui-validate=&quot;&#123;wrongphone: &apos;wrongPhoneNumber($value)&apos;&#125;&quot;&gt;&lt;div ng-show=&quot;form.phoneNumber.$error.wrongphone&quot;&gt; 错误信息&lt;/div&gt; 相应的在控制器中定义wrongPhoneNumber方法的内容：123456789101112$scope.wrongPhoneNumber = function(value)&#123; if(value.length == 0 || value.length != 11)&#123; return false; &#125; var myreg = /^((\\(\\d&#123;2,3&#125;\\))|(\\d&#123;3&#125;\\-))?13\\d&#123;9&#125;$/; if(!myreg.test(value))&#123; return false; &#125; return true;&#125; ui-validate指令中以键值对的方式写一个对象，这个键就是加入到 $error中的新属性，这个值就是一个表达式，可以写函数，我就是在这一步遇到了莫名其妙的问题，我定义了方法，但是它怎么都没反应，检测不了错误。我将方法的定义检查了一万次，确定没错，苦苦思索无果，最后偶然的试验下才知道，这个表达式里的结果为 false 时，属性才会加入到 $error 中显示 true。有点绕，试验一次就知道了。 大概就是如此，还有一点就是传进去的那个 $value的值其实就是输入框输入的值，那么在控制器中就不用使用 ng-model 绑定输入框然后操作数据那么麻烦了，我试过好像还有点延迟不太同步的现象。 真正把 AngularJS 用在项目中深切感觉到其强大便利之处，虽然这个摸索过程艰辛无比，但熟悉了之后，发现一切都变得那么轻便快捷，不过 HTML 代码明显变多且复杂了…","tags":[{"name":"AngularJS","slug":"AngularJS","permalink":"http://famousczm.github.io/tags/AngularJS/"}]},{"title":"AngularJS简单说说我对三大作用域的理解","date":"2017-07-15T07:10:40.000Z","path":"2017/07/15/AngularJS简单说说我对三大作用域的理解/","text":"最近在看《AngualrJS 权威教程》，深感这个框架确实有点消耗脑力，明明每个字都会读，连在一起怎么就不懂了呢 (´_ゝ`) 。看到三大作用域（外部作用域，继承作用域和隔离作用域）那里刚开始有点乱，现在理清了思路简单说说我的理解。 外部作用域这个很容易理解，就是当前指令的作用域以外的作用域就是外部作用域，例如父级作用域，爷级作用域之类的。 继承作用域从父级作用域继承并创建一个新的子作用域，这个子作用域就是继承作用域，它拥有父级作用域定义的的属性，可以在定义指令的时候用 scope: true来声明，这样使用该指令的时候就会生成一个继承作用域，如常见的内置指令 ng-controller就是这种类型。也就是说继承作用域能访问获取它父级作用域的属性，而父级作用域则不能访问继承作用域的，学过 Java 或其它面向对象语言的朋友应该都不难理解，举个栗子： HTML12345678&lt;div ng-init=&quot;fatherProperty=&apos;我在父级作用域生成&apos;&quot;&gt; 我是父级作用域: &#123;&#123; fatherProperty &#125;&#125;&lt;br/&gt; 我是父级作用域: &#123;&#123; sonProperty &#125;&#125; &lt;div ng-controller=&quot;son&quot;&gt; 我是继承作用域: &#123;&#123; fatherProperty &#125;&#125;&lt;br/&gt; 我是继承作用域: &#123;&#123; sonProperty &#125;&#125; &lt;/div&gt; &lt;/div&gt; JavaScript1234var app = angular.module(&apos;myApp&apos;, []);app.controller(&apos;son&apos;, function($scope)&#123; $scope.sonProperty = &quot;我在子作用域生成&quot;;&#125;); 结果为：1234我是父级作用域: 我在父级作用域生成我是父级作用域:我是继承作用域: 我在父级作用域生成我是继承作用域: 我在继承作用域生成 一目了然。还有一点是，在继承作用域修改父级作用域的属性值时，父级作用域的属性值会不会也被改变呢？如果也被改变了那么继承作用域继承的是属性引用，如果没被改变就是单纯的属性复制了。栗子： HTML123456&lt;div ng-init=&quot;fatherProperty=&apos;我在父级作用域生成&apos;&quot;&gt; 我是父级作用域: &#123;&#123; fatherProperty &#125;&#125;&lt;br/&gt; &lt;div ng-controller=&quot;son&quot;&gt; 我是继承作用域: &#123;&#123; fatherProperty &#125;&#125;&lt;br/&gt; &lt;/div&gt; &lt;/div&gt; Javascript1234var app = angular.module(&apos;myApp&apos;, []);app.controller(&apos;son&apos;, function($scope)&#123; $scope.fatherProperty = &quot;我在继承作用域改变了&quot;;&#125;); 结果是：12我是父级作用域: 我在父级作用域生成我是子作用域: 我在子作用域改变了 OK，属性复制。但也只是限于属性是字符串、数字之类的值而已，当继承的是数组或对象的话，就是属性引用了。栗子： HTML123456&lt;div ng-init=&quot;fatherProperty=&#123;data: &apos;我在父级作用域中生成&apos;&#125;&quot;&gt; 我是父级作用域: &#123;&#123; fatherProperty.data &#125;&#125;&lt;br/&gt; &lt;div ng-controller=&quot;son&quot;&gt; 我是继承作用域: &#123;&#123; fatherProperty.data &#125;&#125;&lt;br/&gt; &lt;/div&gt; &lt;/div&gt; Javascript1234var app = angular.module(&apos;myApp&apos;, []);app.controller(&apos;son&apos;, function($scope)&#123; $scope.fatherProperty.data = &quot;我在继承作用域改变了&quot;;&#125;); 结果是：12我是父级作用域: 我在继承作用域改变了我是继承作用域: 我在继承作用域改变了 继承作用域也就差不多这样，也很好理解。 隔离作用域书上说较难理解的隔离作用域，其实也没多难。外部作用域和继承作用域之间多少有点关系，而隔离作用域如它名字的一样非常内向，很少和别人接触，所以它不像继承作用域一样可以访问它的外部作用域，隔离作用域自己跟自己玩，不能访问外部作用域。 在定义指令时用scope: {}来声明，举个栗子： HTML1234&lt;div ng-init=&quot;fatherProperty=&#123;data: &apos;我在父级作用域中生成&apos;&#125;&quot;&gt; 我是父级作用域: &#123;&#123; fatherProperty.data &#125;&#125; &lt;div my-directive&gt;&lt;/div&gt; &lt;/div&gt; Javascript12345678var app = angular.module(&apos;myApp&apos;, []);app.directive(&apos;myDirective&apos;, function() &#123; return &#123; restrict: &apos;A&apos;, scope: &#123;&#125;, template: &apos;我是隔离作用域: &#123;&#123; fatherProperty.data &#125;&#125;&apos; &#125;;&#125;) 结果是：12我是父级作用域: 我在父级作用域中生成我是隔离作用域: 那么隔离作用域可不可以像 ng-controller 那样可以自己定义属性？ 当然可以自己定义属性，不然还怎么玩，定义属性的方法就是在{}里面定义，但是不能直接给它赋值，只能接受外界的传值（看来也没有很自闭），怎么传，要用绑定策略，看个栗子： HTML1234&lt;div ng-init=&quot;fatherProperty=&#123;data: &apos;我在父级作用域中生成&apos;&#125;&quot;&gt; 我是父级作用域: &#123;&#123; fatherProperty.data &#125;&#125; &lt;div my-directive test=&quot;&#123;&#123;fatherProperty.data&#125;&#125;&quot;&gt;&lt;/div&gt; &lt;/div&gt; Javascript12345678910var app = angular.module(&apos;myApp&apos;, []);app.directive(&apos;myDirective&apos;, function() &#123; return &#123; restrict: &apos;A&apos;, scope: &#123; test: &quot;@&quot; &#125;, template: &apos;我是隔离作用域: &#123;&#123; test &#125;&#125;&apos; &#125;;&#125;); 结果是：12我是父级作用域: 我在父级作用域中生成我是隔离作用域: 我在父级作用域中生成 可以看到，隔离作用域也能访问外部作用域了，其实更像外部作用域将数据从一个接口处传进隔离作用域里…这隔离作用域不但内向还懒啊哈哈。这个 @符号用来接受传进来的字符串然后赋值给属性，但只能接受字符串，所以遇到表达式的时候还要用 { { } } 来翻译成字符串输入。用=就不用这么麻烦了，直接写就 ok，如下： HTML1234&lt;div ng-init=&quot;fatherProperty=&#123;data: &apos;我在父级作用域中生成&apos;&#125;&quot;&gt; 我是父级作用域: &#123;&#123; fatherProperty.data &#125;&#125; &lt;div my-directive test=&quot;fatherProperty.data&quot;&gt;&lt;/div&gt; &lt;/div&gt; Javascript12345678910var app = angular.module(&apos;myApp&apos;, []);app.directive(&apos;myDirective&apos;, function() &#123; return &#123; restrict: &apos;A&apos;, scope: &#123; test: &quot;=&quot; &#125;, template: &apos;我是隔离作用域: &#123;&#123; test &#125;&#125;&apos; &#125;;&#125;); 结果同上。 如果直接把 fatherProperty这个对象传进去，则隔离作用域内的属性test接受的是一个对象，输出时应为 。 隔离作用域目前也了解至此。 That’s all ~","tags":[{"name":"AngularJS","slug":"AngularJS","permalink":"http://famousczm.github.io/tags/AngularJS/"}]},{"title":"AngularJS实现两种表单错误处理的方式","date":"2017-07-09T11:59:44.000Z","path":"2017/07/09/AngularJS实现两种表单错误处理的方式/","text":"AngularJS 的自动双向数据绑定的确非常强大，对表单的处理也十分出色。它能和 HTML5 的混合使用更是让我震惊不已，这里我利用 AngularJS 的强大简便地实现表单的两种错误处理方式。 表单错误处理即在输入表单数据时实时判断数据的正确与否并将错误提示显示给用户。第一种是当输入框失焦时才显示错误信息；第二种是当点击提交按钮时才显示错误信息。 失焦才显示错误信息自定义一个 Directive 命名为 ngFocus，app.js代码如下：1234567891011121314151617181920var app = angular.module(&apos;myApp&apos;, [&apos;ngMessages&apos;]);app.directive(&apos;ngFocus&apos;, [function()&#123; return &#123; restrict: &apos;A&apos;, require: &apos;ngModel&apos;, link: function(scope, element, attrs, ctrl)&#123; ctrl.$focused = false; element.bind(&apos;focus&apos;, function(evt)&#123; scope.$apply(function()&#123; ctrl.$focused = true; &#125;); &#125;).bind(&apos;blur&apos;, function(evt)&#123; scope.$apply(function()&#123; ctrl.$focused = false; &#125;); &#125;); &#125; &#125;;&#125;]); 设置 Directive 为属性类型，并引入 ngModel Directive，定义数据变量 $focused，用来记录当前是否获得焦点。然后在当前元素上绑定 focus和blur两个事件，根据不同情况分别设置$focused的值。 由于要使用 ngMessages 这个模块，所以在创建 app 模块时要引入这个模块。 index.html的代码如下：12345678910111213141516171819202122232425&lt;form name=&quot;signup_form&quot; novalidate ng-submit=&quot;signupForm()&quot;&gt; &lt;fieldset&gt; &lt;legend&gt;Signup&lt;/legend&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;large-12 columns&quot;&gt; &lt;label&gt;Your name&lt;/label&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Name&quot; name=&quot;name&quot; ng-model=&quot;signup.name&quot; ng-minlength=&quot;3&quot; ng-maxlength=&quot;20&quot; required ng-focus /&gt; &lt;/div&gt; &lt;div class=&quot;error&quot; ng-messages=&quot;signup_form.name.$error&quot; ng-messages-multiple ng-if=&quot;!signup_form.name.$focused &amp;&amp; signup_form.name.$dirty&quot;&gt; &lt;div ng-messages-include=&quot;templates/other.html&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;button radius&quot; ng-disabled=&quot;signup_form.$invalid&quot;&gt; Submit &lt;/button&gt; &lt;/fieldset&gt;&lt;/form&gt; 这里注意的是表单里无论是 form 还是 input 元素都要有 name 属性，因为后面获取输入框信息的时候要用到。 novalidate取消了浏览器对表单的默认验证，我们自己来设置对表单的验证。 ng-submit是提交时执行的函数，这里先不管 input 输入框可设置指令 ng-minlength 和 ng-maxlength 来规定输入的字符串长度，结合 H5 的 required 属性，规定输入框不能为空。再加上刚自定义的 Directive ng-focus，html 中的命名跟 JS 中的不一样，JS 对大小写敏感而 html 不敏感，所以转化的时候要注意。 最底的那个 div 就是错误信息了，我们要控制它的显示，当输入框有输入数据并且失焦的时候我们才去检查它并显示错误提示，其它情况隐藏。要是以往用直接用 JS 写要操作 DOM 很麻烦。而用 AngularJS 超级方便，用 ng-if就可以像平时使用的 if-else 语句一样选择显示了，使用 form名字.input名字.变量名的格式获取想要的数据，这里当输入框数据被更改过而且失焦的时候 显示错误信息。 ng-messages=&quot;signup_form.name.$error&quot;获取错误信息，错误信息包括，required、minlength 和 maxlength，当输入框数据不满足设置条件时，对应的项就会为 true。可以通过打印signup_form.name.$error来深入理解。 ng-messages-multiple可以显示多条错误信息 提交按钮中设置了 ng-disabled=&quot;signup_form.$invalid&quot;，当表单有错误输入时禁止提交，等到全部输入正确后才允许提交 里面包含一个 div ，为了能复用相同的代码，使用ng-messages-include来引入外部文件。这个 other.html 的代码如下：123&lt;small class=&quot;error&quot; ng-message=&quot;required&quot;&gt;不能为空&lt;/small&gt;&lt;small class=&quot;error&quot; ng-message=&quot;minlength&quot;&gt;长度不能少于3位&lt;/small&gt;&lt;small class=&quot;error&quot; ng-message=&quot;maxlength&quot;&gt;长度不能大于20位&lt;/small&gt; ng-message使相关的错误显示对应的错误信息，值为 true 时才显示。 记得要引入外部文件 angular-messages.min.js，并且放在 angular.js 后面不然会报错 。我这里还使用了 foundation 框架，为了少写点样式。 提交才显示错误信息app.js的代码如下：123456789101112var app = angular.module(&apos;myApp&apos;, [&apos;ngMessages&apos;]);app.controller(&apos;myController&apos;, function($scope)&#123; $scope.submitted = false; //submitted为true时才显示错误信息 $scope.signupForm = function()&#123; if($scope.signup_form.$valid)&#123; //正常提交 &#125;else&#123; $scope.signup_form.submitted = true; &#125; &#125;&#125;); 在控制器中定义变量 submitted，提交前为 false，提交后有错误为 true。当表单提交后执行函数 signupForm，判断表单是否有错，没错正常提交，有错将 submmitted 改为 true。 index.html的代码如下：12345678910111213141516171819202122&lt;form name=&quot;signup_form&quot; novalidate ng-submit=&quot;signupForm()&quot; ng_controller=&quot;myController&quot;&gt; &lt;fieldset&gt; &lt;legend&gt;Signup&lt;/legend&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;large-12 columns&quot;&gt; &lt;label&gt;Your name&lt;/label&gt; &lt;input type=&quot;text&quot; placeholder=&quot;Name&quot; name=&quot;name&quot; ng-model=&quot;signup.name&quot; ng-minlength=&quot;3&quot; ng-maxlength=&quot;20&quot; required ng-focus /&gt; &lt;/div&gt; &lt;div class=&quot;error&quot; ng-messages=&quot;signup_form.name.$error&quot; ng-messages-multiple ng-if=&quot;signup_form.submitted &amp;&amp; signup_form.name.$dirty&quot;&gt; &lt;div ng-messages-include=&quot;templates/other.html&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;button radius&quot;&gt; Submit &lt;/button&gt; &lt;/fieldset&gt;&lt;/form&gt; 基本与上一种方法差不多，不过要把判断语句 ng-if 改为判断signup_form.submitted，然后提交按钮去掉 ng-disabled，因为已经没有意义了。 就是这样。","tags":[{"name":"AngularJS","slug":"AngularJS","permalink":"http://famousczm.github.io/tags/AngularJS/"}]},{"title":"AngularJS Directive replace中的一些问题","date":"2017-07-07T08:39:55.000Z","path":"2017/07/07/AngularJS-Directive-replace中的一些问题/","text":"自定义 Directive 中使用 template 和 replace 来定义替换的内容时遇到了1Error: [$compile:tplrt] Template for directive &apos;people&apos; must have exactly one root element. 这样的错误，自定义的名为‘ people ’的 directive 必须只能拥有一个根节点。 部分源程序如下：12345678910111213141516var App = angular.module(&quot;myApp&quot;, []);App.directive(&quot;people&quot;, function()&#123; return &#123; restrict: &quot;E&quot;, replace: true, template: &quot;&lt;p&gt;姓名:&#123;&#123;data.name&#125;&#125;&lt;/p&gt;&lt;p&gt;性别:&#123;&#123;data.sex&#125;&#125;&lt;/p&gt;&quot; &#125;;&#125;);App.controller(&quot;PhoneListCtrl&quot;, function($scope)&#123; $scope.data = &#123; name: &quot;Jack&quot;, sex: &quot;男&quot; &#125;;&#125;); 当 replace 为 false （默认）时，template 的内容插入到自定义的 Directive 中；当 replace 为 true 时，template 的内容替换掉自定义的 Directive 且 template 的内容只能有一个根节点，即只能有一个元素。 所以解决方法是删掉一个 p 元素，或者把 replace 改为 false 。 然后我想能不能在 people 元素内把删掉的 p 元素内容加进去即这样：1&lt;people&gt;&lt;p&gt;性别:&#123;&#123;data.sex&#125;&#125;&lt;/p&gt;&lt;/people&gt; 结果是，不行。 不论是 replace 为 true 或者 false，people 里面的内容全部都会被 template 替换掉，要想保存 people 里原有的内容，要加入transclude: true，并在 template 中加入 &lt;div ng-transclude&gt;&lt;/div&gt;来保存原有的内容，修改后的内容为：12345App.directive(&quot;people&quot;, function()&#123; return &#123; restrict: &quot;E&quot;, transclude: true, template: &quot;&lt;p&gt;姓名:&#123;&#123;data.name&#125;&#125;&lt;/p&gt;&lt;p&gt;性别:&#123;&#123;data.sex&#125;&#125;&lt;/p&gt;&lt;div ng-transclude&gt;&lt;/div&gt;&quot; 这几天沉迷于《巫师3》，要是有机会参与开发这样的游戏该是多美妙的事情","tags":[{"name":"AngularJS","slug":"AngularJS","permalink":"http://famousczm.github.io/tags/AngularJS/"}]},{"title":"AngularJS:Uncaught Error: [$injector:modulerr]!问题","date":"2017-06-27T12:47:56.000Z","path":"2017/06/27/AngularJS-Uncaught-Error-injector-modulerr-问题/","text":"使用控制器的时候，出现如下这种错误信息：1234567891011angular.min.js:6 Uncaught Error: [$injector:modulerr] http://errors.angularjs.org/1.6.4/$injector/modulerr?p0=myApp&amp;p1=Error%3A%2…tp%3A%2F%2F127.0.0.1%3A8020%2FAngularTest%2Fjs%2Fangular.min.js%3A22%3A179) at angular.min.js:6 at angular.min.js:42 at q (angular.min.js:7) at g (angular.min.js:41) at eb (angular.min.js:46) at c (angular.min.js:21) at Sc (angular.min.js:22) at ue (angular.min.js:20) at angular.min.js:331 at HTMLDocument.b (angular.min.js:38) 不能获取什么，模块什么的不懂，把压缩版的 Angular.min.js 切换 Angular.js 查看详细错误信息：123Uncaught Error: [$injector:modulerr] Failed to instantiate module myApp due to:Error: [$injector:nomod] Module &apos;myApp&apos; is not available! You either misspelled the module name or forgot to load it. If registering a module ensure that you specify the dependencies as the second argument..... ‘myApp’ 模块得不到。这个 myApp 就是声明 AngularJS 应用的 ng-app=&quot;myApp&quot;，要使用 angular.module 函数来创建模块：1var app = angular.module(&quot;myApp&quot;, []); 创建模块后错误变成：1angular.js:14525 Error: [$controller:ctrlreg] The controller with the name &apos;MyController&apos; is not registered. 我定义的控制器 MyController 还没注册，使用以下方式注册：1app.controller(&apos;MyController&apos;, function($scope)&#123;...&#125;); 然后就可以了。 一般还有些情况是对应的模块文件没有加载，如 angular-route.js 作为一个单独的模块并没有合并到 angular.js 中，所以要单独加载。 要是到这里还没有解决问题的话，就要看看代码有没有写错了，常见的错误是(我平时常犯的 orz)，没有关闭标签 &lt;script&gt; &lt;/script&gt; 学习愉快。","tags":[{"name":"AngularJS","slug":"AngularJS","permalink":"http://famousczm.github.io/tags/AngularJS/"}]},{"title":"微信小程序-事件处理","date":"2017-06-21T14:39:28.000Z","path":"2017/06/21/微信小程序-事件处理/","text":"先看一下微信小程序对事件的解释： 文字叙述一下 什么是事件 事件是视图层到逻辑层的通讯方式。 事件可以将用户的行为反馈到逻辑层进行处理。 事件可以绑定在组件上，当达到触发事件，就会执行逻辑层中对应的事件处理函数。 事件对象可以携带额外信息，如 id, dataset, touches。 就是那些点击、鼠标移进移出之类的动作啦。小程序绑定事件的方法是在 wxml 文件对应的组件中使用 bindtap加上事件名字就可以了。例如：1&lt;view bindtap=&quot;test&quot;&gt;&lt;/view&gt; 然后当点击这个组件的时候小程序就会在该页面对应的脚本文件的 Page 中找到相应的事件处理函数，下面举例写这个 test 事件:123456Page(&#123; .... test: function(event)&#123; console.log(&apos;Click！&apos;); &#125;&#125;) 先点击一下组件，然后打开控制台看看是否成功。毫无疑问是可以的。接下来再看看获得的这个事件里面到底有什么信息 嗯，首先是 type事件类型是 tap ，这个 tap 事件就是手指触摸后马上离开的动作，也就是点击啦。timeStamp为发生事件的时间戳，detail表示事件的某种信息，根据不同的事件会返回不同的信息，这里返回的是点击时的坐标。currentTarget和target这两个属性比较容易搞糊涂，currentTarget在事件流的捕获、目标和冒泡阶段，而target只是在事件流的目标阶段，当事件流是在目标阶段时，这两个的值是一样的，而事件流在捕获和冒泡阶段的话，两个属性的值不一样，下面会具体分析。最后是changedTouches和touches的比较，touches属性当每个事件被触发时，就会获取此时每个触点的信息，并保存在列表中，是只读属性。changedTouches跟差不多也是可以记录触点的信息，但它是根据事件的变法来获取触点的信息，举个栗子就是，当一只手指触碰屏幕时，changedTouches和touches都会同时记录这个触点的信息，信息一样；而当手指离开屏幕时，触点消失，touches中的记录就会消失，而由于这个过程是由接触事件向没有接触事件的变化，所以changedTouches仍然记录着触点移开前的信息，这就是两者之间的区别了。 再举例分析一下currentTarget和target的不同 我先把事件 test 绑定在 Image 组件上，即：1234&lt;view id=&quot;view&quot; class=&quot;userinfo&quot;&gt; &lt;image id=&quot;image&quot; bindtap=&quot;test&quot; class=&quot;userinfo-avatar&quot; src=&quot;&#123;&#123;userInfo.avatarUrl&#125;&#125;&quot; background-size=&quot;cover&quot;&gt;&lt;/image&gt; &lt;text class=&quot;userinfo-nickname&quot;&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt; &lt;/view&gt; 然后点击头像，查看currentTarget和target的信息： 一样，因为目标对象都是 image 组件。再把 test 事件绑定到 image 的父组件 view 上：1234&lt;view id=&quot;view&quot; bindtap=&quot;test&quot; class=&quot;userinfo&quot;&gt; &lt;image id=&quot;image&quot; class=&quot;userinfo-avatar&quot; src=&quot;&#123;&#123;userInfo.avatarUrl&#125;&#125;&quot; background-size=&quot;cover&quot;&gt;&lt;/image&gt; &lt;text class=&quot;userinfo-nickname&quot;&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt; &lt;/view&gt; 然后点击头像，查看currentTarget和target的信息： 可看到信息不一样了，不难发现这次 target 保存的信息是点击的 image 组件的信息，而 currentTarget 保存的是绑定 test 事件的 view 组件的信息。到这里currentTarget和target的区别已经很明显了。 分析完 event 对象，继续分析 currentTarget 对象，因为这个很常用，经常用它来获取触发事件的组件信息，先把它打印出来：123test: function(event)&#123; console.log(event.currentTarget) &#125; 点击头像，获取信息：123456Object &#123;id: &quot;image&quot;, offsetLeft: 156, offsetTop: 110, dataset: Object&#125;dataset:Objectid:&quot;image&quot;offsetLeft:156offsetTop:110__proto__:Object 信息主要有dataset对象，目标组件id的值，还有相对页面的偏移量offsetLeft和offsetTop。 看看 dataset 里面装的是什么123test: function(event)&#123; console.log(event.currentTarget.dataset) &#125; 嗯，什么都没有。查阅文档得知，dataset 是组件上由data-开头的自定义属性组成的集合，所以我们在 view 组件上增加几个自定义属性：1234&lt;view bindtap=&quot;test&quot; data-num=&quot;1&quot; data-hi=&quot;hello&quot; id=&quot;view&quot; class=&quot;userinfo&quot;&gt; &lt;image id=&quot;image&quot; class=&quot;userinfo-avatar&quot; src=&quot;&#123;&#123;userInfo.avatarUrl&#125;&#125;&quot; background-size=&quot;cover&quot;&gt;&lt;/image&gt; &lt;text class=&quot;userinfo-nickname&quot;&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt; &lt;/view&gt; 有了，然后获取数据的时候直接按下面方法使用就行了：12event.currentTarget.dataset.hievent.currentTarget.dataset.num 绑定事件除了用 bind之外还可以用 catch，区别是 bind不会阻止冒泡事件向上冒泡，而 catch会。举例说明：123456789test1: function(event)&#123; console.log(&quot;test1&quot;) &#125;, test2: function (event) &#123; console.log(&quot;test2&quot;) &#125;, test3: function (event) &#123; console.log(&quot;test3&quot;) &#125; 我定义了三个事件，然后绑定在三个嵌套的组件里1234567891011&lt;view bindtap=&quot;test3&quot; class=&quot;container&quot;&gt; &lt;view bindtap=&quot;test2&quot; data-num=&quot;1&quot; data-hi=&quot;hello&quot; id=&quot;view&quot; class=&quot;userinfo&quot;&gt; &lt;view bindtap=&quot;test1&quot; class=&quot;classname&quot;&gt; &lt;image id=&quot;image&quot; class=&quot;userinfo-avatar&quot; src=&quot;&#123;&#123;userInfo.avatarUrl&#125;&#125;&quot; background-size=&quot;cover&quot;&gt;&lt;/image&gt; &lt;text class=&quot;userinfo-nickname&quot;&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;usermotto&quot;&gt; &lt;text class=&quot;user-motto&quot;&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt; &lt;/view&gt;&lt;/view&gt; 点击头像，可以发现： 事件由里向外顺序触发，向冒泡一样。如果在第二层的 view 那里使用 catchtap，即：1234567891011&lt;view bindtap=&quot;test3&quot; class=&quot;container&quot;&gt; &lt;view catchtap=&quot;test2&quot; data-num=&quot;1&quot; data-hi=&quot;hello&quot; id=&quot;view&quot; class=&quot;userinfo&quot;&gt; &lt;view bindtap=&quot;test1&quot; class=&quot;classname&quot;&gt; &lt;image id=&quot;image&quot; class=&quot;userinfo-avatar&quot; src=&quot;&#123;&#123;userInfo.avatarUrl&#125;&#125;&quot; background-size=&quot;cover&quot;&gt;&lt;/image&gt; &lt;text class=&quot;userinfo-nickname&quot;&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class=&quot;usermotto&quot;&gt; &lt;text class=&quot;user-motto&quot;&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt; &lt;/view&gt;&lt;/view&gt; 点击头像： 冒泡在第二层那里被中断了。catch就是这么玩。 完。","tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://famousczm.github.io/tags/微信小程序/"}]},{"title":"微信小程序--demo代码分析","date":"2017-06-20T11:28:15.000Z","path":"2017/06/20/微信小程序-demo代码分析/","text":"微信小程序已经出来很久了，很多公司都开发了自家产品的小程序版本来迎合这股热潮，大家都非常看好小程序，认为这就是未来。我也是这么认为的，虽然好像反响不大，朋友圈里也没怎么看到相关消息，不免觉得有点失望。我觉得大部分的原因是大家都找不到小程序的入口在哪哈哈，因为要激活，然后大部分必要的应用自己手机都有安装，而且用习惯了就直接打开手机上的 APP 就行了，所以就感觉小程序没什么新奇的地方。其实小程序不但对于开发者来说很方便（跨平台，包装很好的 API ，开发成本低等），而且小程序作为 WEB APP 的代表，对于大众来说不仅能节省手机的内存空间还不用花时间去下载安装，个人认为迟早是要替换手机原生 APP 的。 之前刚出的时候是听说只有企业和政府能开发和发布小程序，我就没有去凑一脚了，现在有了个人开发者这一选项，我决定去一探究竟。 顺利注册下载了个微信 web 开发者工具之后，就可以边读文档边开发了，刚开始不太懂小程序的项目架构是怎样的，它还很贴心地为我们准备了个 demo 版本的。作为新手的我肯定是从这里开始学习啦。 先看看开发界面 分三部分，左边就是手机模拟界面，上面有手机型号（默认是 iphone6 ）和 网络选择，中间是项目目录结构，最重要的是以 app 为名字的几个文件，待会分析一下。右边就是编辑器了，相对于其它编辑器来说的确有点简陋，但是胜在界面简洁明了还有自动补全语法提示功能。所以对于开发项目不大的情况下还是可以将就一下的。 马上开始看看这三个文件，app.js、app.json 、 app.wxss。前两个学过前端的都懂是啥，后面的这个 wxss文件是什么？其实就是微信（wx）自己的 css文件，就是用来写页面样式的，与之对应的 html 就变为 wxml文件，用法就是 html 和 xml 的结合。 app.wxss12345678910/**app.wxss**/.container &#123; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: space-between; padding: 200rpx 0; box-sizing: border-box;&#125; 小程序中每个页面都对应一个目录，每个目录都有四个基本文件（js、json、wxss、wxml）。这个样式表起到一个全局的作用，在这里定义的样式在所有页面中都能起作用。由代码可以看出，小程序都用上了流行的弹性盒子 flex 布局的方法。移动端网页设计必备。 app.json123456789101112&#123; &quot;pages&quot;:[ &quot;pages/index/index&quot;, &quot;pages/logs/logs&quot; ], &quot;window&quot;:&#123; &quot;backgroundTextStyle&quot;:&quot;light&quot;, &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;, &quot;navigationBarTitleText&quot;: &quot;WeChat&quot;, &quot;navigationBarTextStyle&quot;:&quot;black&quot; &#125;&#125; 配置文件中的 pages用来放置每个页面的路径，以 [ 路径 + 页面名 ] 的格式存储，创建页面的时候，也可以直接在这里想要创建的页面路径和页面名然后保存，就会自动生成对应的目录和文件。 window也就是配置窗口信息。用来设置最顶端的标题栏的内容。字体颜色、背景颜色等。 app.js12345678910111213141516171819202122232425262728293031//app.jsApp(&#123; onLaunch: function () &#123; //调用API从本地缓存中获取数据 var logs = wx.getStorageSync(&apos;logs&apos;) || [] logs.unshift(Date.now()) wx.setStorageSync(&apos;logs&apos;, logs) &#125;, getUserInfo:function(cb)&#123; var that = this if(this.globalData.userInfo)&#123; typeof cb == &quot;function&quot; &amp;&amp; cb(this.globalData.userInfo) &#125;else&#123; //调用登录接口 wx.login(&#123; success: function () &#123; wx.getUserInfo(&#123; success: function (res) &#123; that.globalData.userInfo = res.userInfo console.log(res.userInfo); typeof cb == &quot;function&quot; &amp;&amp; cb(that.globalData.userInfo) &#125; &#125;) &#125; &#125;) &#125; &#125;, globalData:&#123; userInfo:null &#125;&#125;) app.js 负责处理逻辑的脚本文件。纵观整个文件，只是调用了一个 App() 函数而已。这个函数是小程序里内置的一个函数，用来注册一个小程序，接受一个 object 参数。该参数里面指定小程序的生命周期函数。这个有点像 Android 。不知道是特意借鉴的还是怎样，看来生命周期函数对于一个 App 来说是很重要的。 先看看 onLauch:，当小程序初始化完成时会被触发，执行里面的函数。全局下只能触发一次，也就是每次打开小程序就会触发一次。触发后先使用 wx.getStorageSync(&#39;logs&#39;) || [] 从本地缓存中获取 logs 的数据，如果 logs 有数据的时候，就把数据赋值给变量 logs 。如果没数据或者不存在 logs ，则把变量 logs 初始化为空数组。logs.unshift(Date.now())把当前时间插入到数组的第一个元素前，记录每次打开小程序的时间。然后wx.setStorageSync(&#39;logs&#39;, logs)把数组 logs 的内容存储到本地缓存的 logs 中。 将wx.getStorageSync(&#39;logs&#39;) 打印出来可看到里面记录的值 以数组的形式记录着每次登录时间的时间戳。 再看看最下面的globalData:，从名字可以知道这是定义一些全局数据的。这里只有一个数据userInfo: null，记录用户信息，初始为空。 getUserInfo:由名字可知获取用户信息，此函数中有个形参 cb，这里先不管它是什么，继续看下面的代码。有一个 if else 语句，当this.globalData.userInfo存在或有值的时候，就执行 if 里面的，否则执行 else 里的语句。这个this.globalData.userInfo就是我们刚说的初始化为 null 的用户信息，所以一开始都执行 else 里面的代码。 wx.login()有注释，调用登录接口。success:表示调用成功后执行的回调函数，与此对应的还有fail:调用失败后执行的和complete:调用结束后执行的，即成功失败都执行。所以，调用成功后就来这个wx.getUserInfo()获取用户信息了，不过这个 API 生效的前提是必须先调用wx.login()，获取用户信息函数调用成功后，就把this.globalData.userInfo设置为刚登录的用户信息res.userInfo。再看看这个res.userInfo里到底存储了什么样的用户信息 可看出用户信息是 Object 类型的，avatarUrl就是用户头像的图片地址，还有名字、语言、国家、省份、城市什么的。 接下来就看这个是什么意思了1typeof cb == &quot;function&quot; &amp;&amp; cb(this.globalData.userInfo) 先判断 cb 是不是一个 function 类型，是的话，把刚取得的用户信息作为实参传进函数中，关于使用用户信息的地方由界面可以知道是在 index 这个页面中，再来看看 index.js，最下面那里有这么一段：1234567891011onLoad: function () &#123; console.log(&apos;onLoad&apos;) var that = this //调用应用实例的方法获取全局数据 app.getUserInfo(function(userInfo)&#123; //更新数据 that.setData(&#123; userInfo:userInfo &#125;) &#125;) &#125; 在页面加载的时候调用app.getUserInfo(function(userInfo){...})来获取全局数据，没错，这个语句就是在 app.js 中定义的用来获取用户信息的那一段，参数 cb 就是这里的函数123456function(userInfo)&#123; //更新数据 that.setData(&#123; userInfo:userInfo &#125;) &#125; 结合 index.js 前面设置的1234data: &#123; motto: &apos;Hello World&apos;, userInfo: &#123;&#125; &#125; 这个函数是用来设置userInfo的数据的，userInfo:userInfo中前一个 userInfo 是 data 里的 userInfo ，后一个是传进来的参数 userInfo。再看回 app,js 里的cb(this.globalData.userInfo)，嗯，这里就是把用户信息传进去的。有种绕了几圈的感觉哈哈。 index.wxml12345678910&lt;!--index.wxml--&gt;&lt;view class=&quot;container&quot;&gt; &lt;view bindtap=&quot;bindViewTap&quot; class=&quot;userinfo&quot;&gt; &lt;image class=&quot;userinfo-avatar&quot; src=&quot;&#123;&#123;userInfo.avatarUrl&#125;&#125;&quot; background-size=&quot;cover&quot;&gt;&lt;/image&gt; &lt;text class=&quot;userinfo-nickname&quot;&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;view class=&quot;usermotto&quot;&gt; &lt;text class=&quot;user-motto&quot;&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt; &lt;/view&gt;&lt;/view&gt; 嗯，可看出就是使用用户信息了，这个bindtap=&quot;bindViewTap&quot;用来绑定事件，当点击头像或者名字的时候就会触发事件执行 index.js 中设置的事件处理函数 bindViewTap12345bindViewTap: function() &#123; wx.navigateTo(&#123; url: &apos;../logs/logs&apos; &#125;) &#125; wx.navigateTo()用来跳转页面，跳转到日志页面 logs 里去 logs.js12345678910111213var util = require(&apos;../../utils/util.js&apos;)Page(&#123; data: &#123; logs: [] &#125;, onLoad: function () &#123; this.setData(&#123; logs: (wx.getStorageSync(&apos;logs&apos;) || []).map(function (log) &#123; return util.formatTime(new Date(log)) &#125;) &#125;) &#125;&#125;) 开头引入 util.js 。util.js 是用来把时间戳转化为我们能读懂的时间格式，具体实现这里就不深究了。logs 页面加载时从本地缓存中取得日志信息，然后用 map 方法加 util 里的转换格式方法，把数组里的时间戳都转换为可阅读的时间格式。查看 logs 数组信息如下： 大概整个 demo 就是这么多内容了，希望小程序能够越做越好，被大众所重视。","tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://famousczm.github.io/tags/微信小程序/"}]},{"title":"HSLA与RGBA","date":"2017-06-11T03:20:17.000Z","path":"2017/06/11/HSLA与RGBA/","text":"选择颜色的时候我一般使用 rgba 的方式，简便易理解，所有颜色都是由三原色（红、绿、蓝）各种混合而成。但其实真正明白 CSS3 的 HSLA 就知道 HSLA 其实更好用，例如在在提高颜色亮度方面非常方便。 HSLA 是由 H：HUE（色调）、S：Saturation（饱和度）、L：Lightness（亮度）和 A：Alpha（透明度）组成。控制颜色的是色调，0 为红色、120 为绿色、240 为蓝色 如红色就是1background-color: hsla(0, 80%, 50%, 1); 然后把亮度调到 80%，即：1background-color: hsla(0, 80%, 80%, 1); 颜色变浅了 如果亮度为 30% ：1background-color: hsla(0, 80%, 30%, 1); 变暗红了。 来电极端的，亮度为 100% ：1background-color: hsla(0, 80%, 100%, 1); 变为白色了，不管什么颜色都好，只要亮度为 100% 都为白色，亮度为 0% 都为黑色。 再试试饱和度，那第一个例子，饱和度变为 50%，即：1background-color: hsla(0, 50%, 50%, 1); 颜色感觉浅暗了点，关于这方面的知识我也不是很懂，引用维基百科的说法： 色度指得是色彩的纯度，也叫饱和度或彩度，是“色彩三属性”之一。如大红就比玫红更红，这就是说大红的色度要高。它是HSV色彩属性模式，孟塞尔颜色系统等的描述色彩变量。 从广义上说，黑白灰是“色度=0”的颜色。在各种色彩模型中，对色度有不同的量化模式。 色度由光线强弱和在不同波长的强度分布有关。最高的色度一般由单波长的强光（例如激光）达到，在波长分布不变的情况下，光强度越弱则色度越低。 当饱和度为 0% 时，也是不管什么颜色都好，都会变成灰色1background-color: hsla(0, 0%, 50%, 1); 十六进制色值是 #7F7F7F 饱和度为 100% 就是该颜色最为鲜艳巅峰饱和的状态了，如红色：1background-color: hsla(0, 100%, 50%, 1); 关于 HSLA 的大概了解就是这么多","tags":[{"name":"CSS","slug":"CSS","permalink":"http://famousczm.github.io/tags/CSS/"}]},{"title":"CSS学习小记（五）","date":"2017-06-03T09:24:57.000Z","path":"2017/06/03/CSS学习小记（五）/","text":"height: 100% 没有效果做项目的时候遇到了给一个 div 的样式设置 height: 100% 加上背景颜色，结果没反应，也就是说height: 100% 并没有起作用，之前我用好像都没什么问题。 先来分析一下height: 100% 的作用，是使当前元素的高度与其父元素的高度一样。假如父元素的高度是 100px ，那么该元素的高度也是 100px，height: 50% 的话高度就是 50px，所以在计算该元素的高度之前先要求出父元素的高度。 所以我也给 div 的父元素 body 也设置了个 height: 100% ，可是页面还是没有反应，因为 body 还有个父元素 html ，所以也要给 html 设置了个 height: 100%，这样才起效果。 页面的宽度没有设置的话默认是 width: 100%，但是高度就不行了，浏览器高度没有默认值，所以必须设置高度的值才会有效。 rem做 WEB APP 的时候考虑屏幕适配时接触的一个长度单位，和 px 、 em 这些差不多，rem 是（font size of the root element），根据根元素去适配字体大小，广泛被用来做移动端的响应式适配。为什么？因为它跟 px 不一样，rem 是根据根元素字体大小的不同设置来转换成不同大小的 px 。所以 rem 的大小不是固定不变的。 使用 rem 前，先在根元素也就是 html 元素上定义一个字体大小，如：123html&#123; font-size: 30px;&#125; 那么该页面下所有使用 rem 为长度单位的元素都会以上面这个字体大小为基准转换成相应的 px。如：12345div&#123; width: 5rem; height: 2rem; background: #999;&#125; 那么这个 div 的长和宽的转换方式就是各自乘于 30 (也就是根元素设置的字体大小)所得到的结果就是对应的 px 了。也就是等价于：12345div&#123; width: 150px; height: 60px; background: #999;&#125; 所以利用这一特性，只要用媒体查询或者 JS 的方法根据不同的屏幕大小改变根元素的字体大小就可以做到自适应屏幕大小了。 还有一问题就是知道目标屏幕大小如何求出对应的根元素字体大小。 有一种方法，先得到原网页的宽度 A，再找到目标屏幕的宽度 B，将 B / A 得到的数值就是这个比例值，然后将原网页的根元素字体大小乘于这个比例值就得到目标屏幕的根元素字体大小。 By the way，一般主流的浏览器默认的字体大小是 16px JQuery 一些问题插写一条 JQuery 的问题，最近在看《JQuery 权威指南》的时候因为书出版太久的原因，一些内容与现在最新版的 JQuery 有些出入，碰了不小壁。这里记录一下。 从 JQuery 1.8 开始，ajaxStop() 和 ajaxStart() 等实现 AJAX 的方法只能绑定 document 元素，也就是说只能这样用：1$(document).ajaxStop(callback); 这个改变也没有什么不方便的 JQuery 的 submit 方法不知道从什么时候开始，不能直接绑定在 input 元素上了，只能绑定在 form 元素上。这个改变也是挺好的，毕竟提交的是表单，更加一目了然。 书中有一个使用 JQuery 的 Cookie 插件保存表单内容到浏览器的例子，里面有个 checkbox 框让用户选择是否保存信息。判断的方法是：123if($(&quot;#chkSave&quot;).attr(&quot;checked&quot;))&#123; /*内容*/&#125; 无奈并没有结果，调试发现$(&quot;#chkSave&quot;).attr(&quot;checked&quot;)的值是undefine，无论有没有勾选复选框。 理由我懂，因为复选框里根本没有设置checked这个属性，加上这个属性后，就意味着默认是选中的状态，上面代码也能生效了。但是这明显不是我想要的结果。 我改用：123if($(&quot;#chkSave&quot;).is(&quot;:checked&quot;))&#123; /*内容*/&#125; 就搞定了 之后再上网查了下，看了几篇博文，才明白原来 jQuery 1.6 开始新增了一个方法 prop() 估计是用来将功能分工的，马上用 prop 试试：123if($(&quot;#chkSave&quot;).prop(&quot;checked&quot;))&#123; /*内容*/&#125; 也是成功了。这两个都具有设置和获取元素属性的方法要怎样使用，官方给出的建议是：具有 true 和 false 两个属性的属性，如 checked, selected 或者 disabled 使用prop()，其他的使用 attr() 如此就明白了该怎么使用了，具体参考博客： jQuery 中 attr() 和 prop() 方法的区别","tags":[{"name":"CSS","slug":"CSS","permalink":"http://famousczm.github.io/tags/CSS/"}]},{"title":"用CSS实现的效果（一）","date":"2017-05-21T07:07:18.000Z","path":"2017/05/21/用CSS实现的效果（一）/","text":"怎么用 CSS 实现鼠标指向某个图标会自动在该图标上方显现相关内容呢？效果如下： 可以在该内容区块内再定义一个 div 区块，这个新区块就是要显示的内容了。1234&lt;div class=&quot;icon&quot; tabindex=&quot;1&quot;&gt; &lt;i class=&quot;fa fa-smile-o&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &lt;div class=&quot;title&quot;&gt;Smile&lt;/div&gt;&lt;/div&gt; 然后就是为该内容设置样式了，要做一个悬浮于图标上方的有点圆角黑色类似对话框的样式。先做圆角黑框。123background:rgba(0,0,0,0.75);padding:10px 15px;border-radius:4px; 目前这样挤在图标中很难看，要让它们分离出去，用绝对布局的方式123456z-index:2;position:absolute;top:-110%;left:50%;-webkit-transform:translateX(-50%); transform:translateX(-50%); 就变成了这个样子 接下来是做成对话框的样子，要加个小尾巴，这要用到:after选择器加上绝对布局了。通过设置border:10px solid transparent位小尾巴准备了一个实心的 20*20 的透明正方形空间，然后用border-top:10px solid rgba(0,0,0,0.75)来显示正方形上边的三角形，也就是我们要实现的小尾巴了。代码如下：12345678910.icons &gt; .icon .title:after&#123; content:&apos;&apos;; position:absolute; border:10px solid transparent; border-top:10px solid rgba(0,0,0,0.75); bottom:-20px; left:50%; -webkit-transform:translateX(-50%) translateY(0px); transform:translateX(-50%) translateY(0px);&#125; 然后要把提示信息隐藏起来，比较常见的做法是用display:none，但这里我用opacity:0来隐藏，即把这个区块完全透明了，然后当鼠标指向图标的时候再把它显示，即：123.icons &gt; .icon:hover .title&#123; opacity:1;&#125; 为了使这个提示信息平稳地显示，再加点延迟：1234.icons &gt; .icon .title&#123; -webkit-transition:all 0.25s; transition:all 0.25s;&#125; 就完成了。 还有一个也是用 CSS 实现的功能。当点击图标的时候，图标能稍微欢快地弹跳起来再落下去回到原来的位置上，这种动画效果像下面这样： 这效果感觉需要用到 JS 的事件处理吧，其实并不需要，纯 CSS 就可以实现了。 首先要用到:focus选择器，它可以选择那些获得焦点的元素。然后再把焦点图标的背景色变透明一点，以给用户一种它被点击了的感觉。然后就是弹跳！弹跳的实现要用到 animation 属性。代码如下：12345.icons &gt; .icon:focus&#123; background:rgba(255,255,255,0.5); -webkit-animation:bounce 1s; animation:bounce 1s;&#125; 然后具体实现跳跃部分：12345678910111213141516171819202122@keyframes bounce&#123; 0%&#123; -webkit-transform:translateY(0px) translateX(0.1px); transform:translateY(0px) translateX(0.1px); &#125; 25%&#123; -webkit-transform:translateY(-40px) translateX(0.1px); transform:translateY(-40px) translateX(0.1px); &#125; 50%&#123; -webkit-transform:translateY(0px) translateX(0.1px); transform:translateY(0px) translateX(0.1px); &#125; 75%&#123; -webkit-transform:translateY(-20px) translateX(0.1px); transform:translateY(-20px) translateX(0.1px); &#125; 100%&#123; -webkit-transform:translateY(0px) translateX(0.1px); transform:translateY(0px) translateX(0.1px); &#125;&#125; 嗯，可以愉快地弹跳了。 到目前为止，大三仅剩下一个课程设计的答辩和一个四级考试 ORZ，基本上算结束了，新的征程即将开始，这个暑假要去实习了！！！","tags":[{"name":"CSS","slug":"CSS","permalink":"http://famousczm.github.io/tags/CSS/"}]},{"title":"CSS学习小记（四）","date":"2017-05-17T14:15:19.000Z","path":"2017/05/17/CSS学习小记（四）/","text":"box-sizing在做项目的过程中，有时定义了两个宽度相同的 div ，但是为其中一个添加了 padding 和 border 之后，宽度却不一样了，因为被 padding 和 border 硬生生给撑开了，这种事情是非常苦恼的，之前是通过减少宽度来使总宽度保持一致。直到发现了这个属性。 box-sizing 属性用于更改用于计算元素宽度和高度的默认的 CSS 盒子模型。可以使用此属性来模拟不正确支持CSS盒子模型规范的浏览器的行为。 我的那个问题只需要在两个 div 内设置box-sizing:border-box就 ok 了，这属性设置的意思是此元素的内边距和边框不再会增加它的宽度。这样 div 的宽度就不会因为 padding 和 border 的设置而改变了。 默认值是box-sizing:content-box，这个就是平时说的标准盒子模型了，设置边框和内边框会使宽度增加。 由于这也是实验中的属性，使用时最好加上浏览器前缀。 transform-style 和 outline-styletransform-style这个属性用于指定使用该属性的元素的子元素是位于三维空间还是二维平面上。所以其值有两个，flat 和 preserve-3d。flat指定子元素位于平面内，是默认值。preserve-3d指定子元素位于三维空间中。在实现3D效果时，该属性起到非常关键的作用。 outline-style属性是用于设置一个元素轮廓的样式。那么轮廓是什么？跟边框有什么区别吗？ 轮廓是围绕元素绘制的线，在边框边缘之外，以突出元素。边框是矩形的且占据一定空间，而轮廓虚无缥缈，不一定是矩形也不占据空间。 outline-style的取值和border-style差不多，而border是集合了border-style、border-width、border-color三种属性的简写属性，同理，outline也是集合了outline-style、outline-width、outline-color三种属性的简写属性。用法也就和border一样。 显示 title 标签内容以前我一直认为 title 标签只是设置网页顶部的文字，只存在于那里。直到我偶然地使用JQuery选择器将所有的元素显示出来时，即如下语句：1$(&quot;*&quot;).css(&quot;display&quot;,&quot;block&quot;); 发现多了个奇怪的字符，对比了一下文档中只有 title 元素才设置了这个值。用开发者工具查看，原来 title 元素平时默认是隐藏的。嘛，这的确是些微不足道的细节，但是突然发现这些细节时又会觉得很惊奇像发现什么新大陆似的。 下个星期要去面试了，希望一切都好","tags":[{"name":"CSS","slug":"CSS","permalink":"http://famousczm.github.io/tags/CSS/"}]},{"title":"小项目:Jquery实现夜间模式","date":"2017-05-16T04:54:03.000Z","path":"2017/05/16/小项目-Jquery实现夜间模式/","text":"项目起源手机的看书软件有夜间模式来降低屏幕的亮度，在黑夜的环境下使眼睛没有那么疲惫。所以想到在用户浏览网页的时候也有这个功能就好了。而且实现也不难，在借鉴一些前辈的思路完成了这个作品 项目功能按下按钮使背景颜色变深，文字颜色变亮，再按一下就回复原状 实现思路按钮用隐藏 checkbox ，把 label 设置成按钮的方法。然后监听 checkbox 如果发生 onchange 事件，就判断 checkbox 是否为 changed ，若是改变背景和字体颜色，若不是，变为原来的颜色。 代码实现HTML12345&lt;div class=&quot;mode&quot;&gt; &lt;input type=&quot;checkbox&quot; name=&quot;check&quot; id=&quot;mode&quot; class=&quot;mode__i&quot; /&gt; &lt;label class=&quot;mode__l&quot; for=&quot;mode&quot;&gt;&lt;/label&gt;&lt;/div&gt;&lt;p&gt;Today is a nice day&lt;/p&gt; label 标签要关联 input CSS这里我用定义全局变量的做法把背景颜色和文字颜色定义好：123456789:root&#123; --light:#ddd; --dark:#333; --text:var(--dark); --bg:var(--light); --size:100%;&#125; 隐藏 checkbox123.mode__i&#123; display:none;&#125; 用 label 代替 checkbox123456789.mode__l&#123; /*准备代替checkbox*/ display:block; position:relative; width:140px; height:40px; margin:0 auto; border-radius:20px; background:#888;&#125; 画出按钮的样式12345678910111213141516171819202122232425262728293031323334.mode__l:hover&#123; cursor:pointer;&#125;.mode__l::before&#123; /*画圆*/ position:absolute; top:0; left:calc(50% - 20px); background:#555; border-radius:20px; transition:all 300ms; transform:translateX(-50px); width:40px; height:40px; content:&apos;&apos;; z-index:1;&#125;.mode__l::after&#123; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); font-size:14px; font-family:monospace; color:#fff; content:&apos;day&apos;;&#125;.mode__i:checked + label::before&#123; transform:translateX(50px);&#125;.mode__i:checked + label:after&#123; content:&apos;night&apos;;&#125; JavaScript123456789$(&apos;#mode&apos;).on(&apos;change&apos;,function()&#123; if($(&apos;#mode&apos;).is(&apos;:checked&apos;) === true)&#123; $(&apos;body&apos;).css(&apos;--bg&apos;,&apos;var(--dark)&apos;); $(&apos;body&apos;).css(&apos;--text&apos;,&apos;var(--light)&apos;); &#125;else&#123; $(&apos;body&apos;).css(&apos;--bg&apos;,&apos;var(--light)&apos;); $(&apos;body&apos;).css(&apos;--text&apos;,&apos;var(--dark)&apos;); &#125;&#125;); 记得要先引入 JQuery 文件 运行结果 详细代码我放在了 github 上 点我","tags":[{"name":"项目","slug":"项目","permalink":"http://famousczm.github.io/tags/项目/"}]},{"title":"JS学习小记（三）","date":"2017-05-15T04:45:04.000Z","path":"2017/05/15/JS学习小记（三）/","text":"return 后面换行的问题这是在一个 JS 的面试题里看到的，觉得应该注意一下，先看下面的两个函数：12345function fool()&#123; return&#123; bar:&quot;hello&quot; &#125;;&#125; 123456function foo2()&#123; return &#123; bar:&quot;hello&quot; &#125;;&#125; 这两个函数好像没什么不一样的地方，除了 return 后面的花括号一个是在同一行上，一个换行了。根据以往的编程经验，这种无所谓的事情到了 JS 中就要注意一下了，分别调用两个函数的结果如下: 为什么 return 后面换行之后就是 Undefined 了呢？ 一般编程语言的;是起到将两个语句分隔的作用，在 JS 中，只要一个语句自己独占一行的话，后面不用写;编译也不会有问题的，解析器会根据换行来判断两个语句是否独立。因此当使用到return、break、continue等语句后面换行时，解析器就误以为在这一行已经结束了，相当于：123456function foo2()&#123; return; &#123; bar:&quot;hello&quot; &#125;;&#125; 所以就返回了个 undefined. 我平时的习惯都是后面紧跟花括号的哈哈，喜欢直接换行的朋友要注意一下了，不然发生错误的话我还真猜不到居然是这里出错了。 let 和 constlet 是什么？let 是更完美的 var 到这里，我们明白了 let 是声明变量的另一种方法。但明明已经有 var 了，为什么还要用 let 呢？这要从 JavaScript 在设计之初引起的一些错误特性说起…这里不提，let 是为了弥补 var 的不足而诞生的，如我之前说的 var 没有块级作用域，而 let 有；let 声明的全局变量不再是全局对象的属性了，而是存在于全局对象之外的一个不可见的作用域中，真正意义上的全局；用 let 重定义的时候会报错，所以 let 好像比较适合与严格模式；let 声明的变量直到控制流到达该变量被定义的代码行时才会被装载，这意味着在这之前调用 let 声明的变量的话就会报错，很严谨，跟 var 不一样。 感觉 var 用多了会变得越来越不严谨哈哈，这对编程来说可不好。 那么 const 有是什么？ const 和 let 是同一时期的产物，基本功能一样，唯一的区别就是，const 必须在声明时赋值，只声明不赋值是会报错的，而且声明赋值后，重新给它赋值也是会报错的。感觉 const 更像传统意义上的全局变量啊。 为了迎合 ES6，以后还是多用 let 吧，大势所趋。 0.1 + 0.2 ！= 0.3？又来一个 JS 奇葩的特性，当执行下面的语句时：1console.log(0.1 + 0.2 == 0.3); 结果是莫名其妙的 false。就好像有人告诉我 1+1 不是等于 2 一样，一脸懵逼。 再输出 0.1 + 0.2 看看结果是什么 看到这串怪异的数字就意识到事情并不简单，JS 中的 Number类型是浮点型来的，而且是二进制的浮点型，其运算过程是，先将 0.1 和 0.2 转换为二进制浮点数进行运算，再将结果转换成十进制输出。二进制浮点数并不能精确表示类似 0.1 这样的数字，所以会有舍入误差。 那么解决方法是：1234567function add(num1,num2)&#123; let r1,r2,m; r1 = (&apos;&apos; + num1).split(&apos;.&apos;)[1].length; r2 = (&apos;&apos; + num2).split(&apos;.&apos;)[1].length; m = Math.pow(10,Math.max(r1,r2)); return (num1 * m + num2 * m) / m;&#125; 先升幂再降幂 Happy Hacking!","tags":[{"name":"JS","slug":"JS","permalink":"http://famousczm.github.io/tags/JS/"}]},{"title":"从修改hosts文件科学上网中理解DNS（下）","date":"2017-05-13T05:26:49.000Z","path":"2017/05/13/从修改hosts文件科学上网中理解DNS（下）/","text":"上次简单说了下 hosts 文件的作用，然后又看了很多这方面的资料，再来总结一下： 在很早之前，全球的网络主机还很少的时候，IP 地址的映射主要靠的就是各主机里的 hosts 文件来实现，那时候的 hosts 文件保存着互联网上所有主机地址的映射。而 hosts 文件的更新是由一个专门来维护 hosts 文件的站点来实现。也就是说那时根本就不需要也没有 DNS 服务器这东西，用自己主机上的 hosts 文件就可以找到对方的 IP 地址然后建立连接了。 但是很明显随着互联网的规模增大，hosts 文件根本不可能存放这么多地址映射的记录，而且这个数量级光数查找就要好些时间了，效率很低。最可悲的还要算那个负责维护更新的站点，要同时为世界上所有主机更新规模巨大的 hosts 文件。 所以 DNS 就这么来了，DNS 承包了 hosts 文件的工作，用来记录世界上各个主机的地址映射（如此一来，hosts 文件已经渐渐被荒废了），当一台主机需要访问另一台主机时，向 DNS 服务器发送一个请求，DNS 服务器就会返回目标主机的 IP 地址回来了。 那么又想到，全世界主机的地址映射都存放在同一台服务器上，并且接受所有主机的请求，一台 DNS 服务器还是承担不了这个重任。但其实 DNS 服务器是层级而且是分布式的，也就是说每个各个主机分成许多个不同的区域，好像我们写地址一样，由大到小，从国家一直到市镇，每个区域有自己的 DNS 服务器群。 所以我们平时访问的域名地址也是按照这种从小到大的顺序命名的，方便 DNS 服务器查找。如：gmail.google.com，最右的就是顶级域名.com了，这我们都很熟悉，目前世界上已有超过250个顶级域名了，例如中国的.cn第二个.google就是隶属于.com下的二级域名了，以此类推有三级域名四级域名等。一般都不会超四吧，反正我就没见过了，四级域名都有点少见。 用一棵树来比喻可能更好理解，每个顶级域名都对应多个 DNS 服务器（里面包含一个 master 服务器和多个 slave 服务器，slave 服务器主要用来备份数据，加快解析地址的速度，保证系统的可用性等），每个区域的域名服务器除了保存它们所在地区的主机的地址映射外，还有其父域名服务器和子域名服务器的地址映射，以此关联起来。 这里还说一个重要的，就是域名地址的类型分好几种12345A类型 就是主机的 IPv4 地址了AAAA类型 这个代表新兴的 IPv6 地址NS类型 表示该域名所在区域的权威域名服务器MX 接受特定域名电子邮件的服务器域名CNAME 当前域名的一个别名 然后到这里可能又会产生一个问题就是顶级域名已经是最顶级的域名了，它们没有父级域名，那么顶级域名之间怎么通信呢？ 根域名服务器帮我们解决这个问题，它保存了所有顶级域名区域的权威域名服务器记录。所以这是一个十分重要的服务器，截止2014年10月，全球共有504台根域名服务器，嘛~大部分都是被美国控制的。 一般电脑连接上网后，会自动获得一个默认的 DNS 服务器，称为本地域名服务器。查看本机的DNS 服务器的地址方法是：windows打开命令行，输入ipconfig /all即可 当然，也可以自己手动设置自己可信任的 DNS 服务器，因为之前说过的 DNS 污染导致的安全问题，所以手动设置的方法是： 以 Win10 位例，右击桌面右下角的网络图标 -&gt; 打开网络共享中心 -&gt; 更改适配器设置 -&gt; 选择你连接的网络的图标右键 -&gt; 属性 -&gt; 选中 Internet 协议版本4 按属性 可看出，一般都是默认自动获取的，勾选 使用下面的 DNS 服务器地址 就可以手动设置了。 之前在很多地方都看见一个为8.8.8.8的地址，这是啥地址？其实这就是所谓的 Google Public DNS，是由 Google 推出的公共免费域名解析服务，目的在于改进网络浏览速度，改善网络用户浏览体验。之前有段时间中国防火长城封锁了这个地址，后来虽然解封了，但毕竟服务器是在国外，怎么也比不上国内的 DNS 服务器来得快，所以也不常用，但可以信赖。除了8.8.8.8，8.8.4.4也是 Google 的。 最后再简单说一下用户请求 DNS 服务器返回目标主机地址的流程。 首先，用户 A 要访问用户 B ，用户 A 向其本地域名服务器发送请求，如果用户 B 与用户 A 在同一区域内，则本地域名服务器直接返回地址，贼快。如果用户 B 在遥远的其它地方，我一直以为本地域名服务器会访问它的父级域名服务器，再沿着树一直往上寻找。然而并不是这样的，本地域名服务器自己没有后，会直接请求根域名服务器，根域名服务器会返回一个顶级域名服务器的地址，然后本地域名服务器再去请求该顶级域名服务器，顶级域名服务器再返回一个其它的域名服务器地址回来，本地域名服务器一直这样根据这些地址来请求相应的域名服务器（真是域名服务器界的劳模），直到找到目标主机的地址再返回给用户主机，用户主机用这个地址直接与目标主机建立连接，域名解析完成。 好吧，写完了，真的是每写一篇博文都要花费一个两三小时的时间啊。一直忙于考试，终于能抽出时间来写了。 参考资料：维基百科从理论到实践，全方位认识DNS（理论篇）","tags":[{"name":"计算机","slug":"计算机","permalink":"http://famousczm.github.io/tags/计算机/"}]},{"title":"CSS学习小记（三）","date":"2017-05-10T15:03:03.000Z","path":"2017/05/10/CSS学习小记（三）/","text":"max-width 属性和 min-width属性这两个属性由字面上来看是就是最大和最小长度，的确是这样。 max-width 属性用来给元素设置最大宽度值. 定义了 max-width 的元素会在达到 max-width 值之后避免进一步按照 width 属性设置变大.也就是说 width 的值怎么也不能超过这个值。一个有点意思的值就是 fit-content ，设置值为 fit-content 时可以使其根据内容的长度来决定最大宽度。设置了 max-width 后，之前设置的 width 就会失效被覆盖。 min-width 属性与 max-width 差不多，设置指定元素的最小宽度，不过它比 max-width 更强，如果设置了 min-width ，之前设置的 width 和 max-width 都会失效被覆盖。 这两个属性一般用于 CSS 媒体查询中 CSS 媒体查询好吧，媒体查询，看名字我还真猜不出是干啥用的。上网查了资料总结一些就是：能够实现“响应式设计”，针对不同的浏览器和设备“呈现”不同显示效果，毕竟不同的设备屏幕大小都会有不一样的状况出现，要使页面能够适应不同的浏览器和设备，可以用弹性盒子实现，也可以用媒体查询来实现 嗯，看起来用处很大，看看是怎么用的 举一个例子：12345@media(max-width: 600px) &#123; .facet_sidebar &#123; display: none; &#125;&#125; 声明一个媒体查询的方式是@media，一个页面中可以有多个，后面跟的是一个或多个表达式，表达式内容会被解释成true或false，当表达式的值都是true时，则执行花括号里的语句，否则不执行。诶….？？？是不是跟什么好像？对，就那个判断语句if，正确则执行。所以媒体查询其实是 CSS 的判断语句？其实也不算，本质是相同的，不过媒体查询还有很多玩法 表达式可以有多个，那么各表达式怎么连起来？可以使用not，and和only 。 当使用and连接时，如下：1(min-width: 700px) and (orientation: landscape) &#123; ... &#125; 起到合并多个表达式（下面统称媒体属性）的作用，只有所有媒体属性都为真时，才执行内容。这相当于&amp;&amp; 吧。 那么，使用or时就是任一个为真就执行咯，除了用or来连接媒体属性还可以用,逗号来代替，效果一样。这个相当于|| 然后使用not就是当媒体属性为假时就为真！！相当于! 使用only用来防止老旧的浏览器不支持呆媒体属性的查询而执行的样式。 除了这些，媒体查询还有很多媒体属性，这里不一一介绍，总结一下，我总算明白媒体查询的意义和名字代表的意思了，这是用于对不同设备做出不同的页面布局调整，用媒体属性来作为一种判断方法区分各种设备，然后在花括号中对不同设备的调整。 :checked又遇到一个伪类了，先从名字上看，马上想到checkbox，对，没错就是与这玩意有关的，而且还和radio有关，当我们选中radio或checkbox或select中的option时，:checked就生效了。所以根据这一特性，我们可以实现选中radio或checkbox或option而使页面产生某种变化的功能。 常规的用法是，给radio加个 :checked ，然后隐藏 radio ，再弄个label标签关联radio ，在：checked 中改变 label 的状态，然后只要点击 label 就会勾选上 radio ，然后触发：checked 改变 label 样式。流程就是这样。用来自定义一个radio的样式我想大概就是用这种方法的吧，毕竟不能直接改它们的样式，真有点想不明白为什么这样设计","tags":[{"name":"CSS","slug":"CSS","permalink":"http://famousczm.github.io/tags/CSS/"}]},{"title":"从修改hosts文件科学上网中理解DNS（上）","date":"2017-05-07T09:43:09.000Z","path":"2017/05/07/从修改hosts文件科学上网中理解DNS（上）/","text":"科学上网的方法有多种，我之前用的免费软件 Lantern 已经开始限流量了。经朋友指点，只要修改电脑中的 hosts 文件就可以访问 Google 了，为什么会这么神奇呢？先看看里面的是什么东西，Window 上的 hosts 文件在C:\\Windows\\System32\\drivers\\etc\\hosts这个地方。用文本编辑器打开： 可以看出里面都是一条条 IP 地址 + 域名的记录，用来进行 IP 地址的映射，当我们在浏览器上输入一个域名的时候，如百度：www.baidu.com，浏览器会先在 这个 hosts 文件中根据域名找到对应的 IP 地址，然后访问目标主机。这个过程是不是很熟悉？对！这就是 DNS (域名解析系统)的工作方式了。 可以发现更熟悉的代表本地计算机的回环 IP 地址的映射127.0.0.1 localhost都是在 hosts 文件中定义的。 接下来就发现了这几条关键的映射了：12345678961.91.161.217 gmail.com61.91.161.217 gmail.google.com61.91.161.217 googlemail.l.google.com61.91.161.217 inbox.google.com61.91.161.217 isolated.mail.google.com61.91.161.217 m.gmail.com61.91.161.217 m.googlemail.com61.91.161.217 mail.google.com61.91.161.217 www.gmail.com 1234567861.91.161.217 www.google.com61.91.161.217 google.com61.91.161.217 gcr.io61.91.161.217 www.gcr.io61.91.161.217 com.google61.91.161.217 admin.google.com61.91.161.217 accounts.google.com61.91.161.217 accounts.google.cn 这几条可以看出一个 IP 地址可以同时对应多个域名，这也就是为什么平时在地址栏上输入google.com或www.google.com都可以访问 google 了。而https://是浏览器自动帮你加上去的。 平时我们访问不了 google 的原因是，google 的域名 在本机转化为 IP 地址后经过中国大陆的防火长城，被防火长城检测到与黑名单内的关键词匹配（如：Google、Facebook、twitter等都在黑名单内），然后就会伪装成目标域名的解析服务器返回虚假的查询结果。关键的是通常的域名查询没有任何认证机制，而且域名的查询一般是基于无连接不可靠的 UDP 协议，所以浏览器只能接受最先到达的格式正确结果，并把之后的所有结果丢弃。所以这也就访问不了啦，这种情况就是所谓的 DNS 缓存污染，也称为 DNS 缓存投毒（这个真形象…） 关于 DNS 缓存污染的定义我引用维基百科的解析： 是指一些刻意制造或无意中制造出来的域名服务器封包，把域名指往不正确的IP地址。一般来说，在互联网上都有可信赖的域名服务器，但为减低网络上的流量压力，一般的域名服务器都会把从上游的域名服务器获得的解析记录暂存起来，待下次有其他机器要求解析域名时，可以立即提供服务。一旦有关域名的局域域名服务器的缓存受到污染，就会把域名内的电脑导引往错误的服务器或服务器的网址。 而黑客使用的DNS 缓存污染攻击则是针对这些特性来进行的。试想一下，如果你的 DNS 缓存被污染了，并且输入一个你常用的域名会跳转到一个黑客指定的网站，而这个网站跟你平时访问的网站几乎一模一样（黑客仿造的），但是访问后会自动帮你下载木马插件。危害可想而知，甚至察觉不了。一般我们上网，都是使用互联网服务供应商提供的域名解析服务器，当用户经常访问一些网站的时候，服务器会将这些网站的域名缓存起来，方便用户下次访问。而黑客就可以专门攻击这些服务器就可以获得用户资料和控制用户的访问了。 扯远了，再来看看为什么这个 hosts 文件访问 google 的 IP 地址就不被防火墙拦截了呢？我查了一下，我这个访问 google 的 IP 地址是香港的，也就是说使用的是香港的代理 IP （Proxy IP）或者说代理服务器（Proxy Server）。那什么是代理 IP 和 代理服务器呢，我们平时访问一个网站，直接把请求信息通过一个 http 包发送到目标服务器上，然后目标服务器返回相应的信息回来。现在我们被墙了，我们不能直接访问目标主机，这就需要有一个可以访问目标主机的机器来帮我们。这就是代理服务器的使命了，我们通过代理 IP 来访问代理服务器，代理服务器帮我们访问我们访问不了的网站，并把相应的信息返回给我们，所以代理服务器必须安置在没有被墙的地方，如香港和台湾或者外国。 如此一来，hosts 的作用和其 IP 映射之类的问题已经明白了，下一篇继续深入分析 hosts 与 DNS 之间的复杂恋情（误！）","tags":[{"name":"计算机","slug":"计算机","permalink":"http://famousczm.github.io/tags/计算机/"}]},{"title":".NET使用MySQL","date":"2017-05-04T15:42:28.000Z","path":"2017/05/04/NET使用MySQL/","text":".NET 课程设计要用到数据库，可是.NET 默认使用的是 SQL Server，这个重量级的数据库软件，我电脑配置不高，运行起来很卡，所以我也就打心底里不想使用它。之前有一段时间有用过，不过已经永远丢失在一段硬盘改革的活动中了。所以我决定使用最亲民的 MySQL 。很多同学觉得 .NET 连接 MySQL 会很麻烦，宁愿下载安装 SQL Server，我只想并不比使用 SQL Server麻烦。下面我简单记录一下我的使用过程： 首先，要下载 MySql.Data.dll 文件（这个网上搜会有） 然后，在项目目录中新建一个 bin 文件夹，并把 MySql.Data.dll 放进去。 在需要连接数据库的 .aspx.cs 文件中使用 using MySql.Data.MySqlClient;引入 连接 MySQL 的相关函数 最后用：123456string conn = &quot;Data Source=127.0.0.1;User ID=root;Password=root;DataBase=db123&quot;;MySqlConnection myconn = new MySqlConnection(conn);myconn.Open();string sql = &quot;select * from table“;MySqlCommand cmm = new MySqlCommand(sql, myconn);myconn.Close(); 再改改相关配置就可以访问数据库和查询数据库中的信息了！！","tags":[{"name":".NET","slug":"NET","permalink":"http://famousczm.github.io/tags/NET/"}]},{"title":"CSS学习小记（二）","date":"2017-05-02T12:32:05.000Z","path":"2017/05/02/CSS学习小记（二）/","text":":root伪类:root 伪类用于匹配文档树的根元素，在 HTML 文档中，:root 表示为&lt;html&gt;元素，声明全局 CSS 变量的时候很有用，用法如下：1234:root&#123; background-color: cornflowerblue; padding: 3em;&#125; 相当于在声明 html 标签的 CSS 变量，不过伪类选择器具有类的特性，优先级比标签选择器要高1234html&#123; background-color: cornflowerblue; padding: 3em;&#125; CSS变量在很多编程语言中，都会有变量这种基本的概念，可以方便地传值赋值，使代码变得清晰易懂，还可以提高程序的性能。但是我在学习 CSS 的过程中一直没有发现有变量的存在，CSS 一直用于描述文档的样式，好像变量的用处也不大。但久而久之，例如开发一些大型网站，很多样式都有重复的值，例如颜色，光写这6个字符组成的十六进制数就很容易让人出错。所以也就越发觉得变量的必要。随着 Sass 等 CSS 预编译工具的流行，变量也逐渐被官方所认可并且规定出来了。 声明一个变量的方法，我们可以在:root里面当做全局变量声明：1234:root&#123; --light: #ddd; --dark: #333;&#125; 在变量名前加上--就可以啦。当在需要使用变量时，用var(变量名)来是使用，十分方便：1234body&#123; color: var(--light); background-color: var(--dark);&#125; 由于这还是个在实验中的功能，所以未来 CSS 变量的语法可能还会改变，让我们继续期待它的成长 opacity属性使一个元素变透明，除了使用rgba()中的设置外，还可以使用opacity属性，更加方便快捷，opacity属性用于指定一个元素的透明度，常与animation 属性使用（个人觉得），取值0到1。0为完全透明，1就是完全不透明啦，用法示范：123&#123; opacity: 0.5;&#125; 不过opacity属性有一个特点，当一个元素使用opacity属性透明时，其子元素也紧随该元素一起透明，即使该元素的子元素设置了不同的opacity值。也就是说一旦元素设置了opacity，那么子元素的opacity就失效了。 对于想实现父元素透明度和子元素透明度不一样的效果，我的做法是父元素使用rgba()来设置透明度，而子元素使用opacity来设置透明度。顺序反过来的话达不到想象中的效果，我也不清楚是怎么回事。 transform属性用 CSS 画图时我最喜欢的属性，功能太强大了（迟些累积好经验后写一篇 CSS 画图的心得）。transform属性有四大功能，分别是translate(转换)、rotate(旋转)、scale(缩放)、skew(倾斜)。因为这个也是 CSS3 的新元素来的，所以实验中，使用最好加前缀。不过只对块级元素有效。 下面简单介绍一下四大功能与用法： translate 用于平移123transform: translate([x,y]); /*[x,y]为平移的坐标*/transform: translateX(x); /*X方向平移*/transform: translateY(y); /*Y方向平移*/ rotate 用于旋转1transform:rotate(angle); /*按顺时针方向旋转一定角度，可以取负数，单位为deg*/ scale 用于缩小和放大123transform:scale(x,y); /*表示一个二维的缩放操作，如果y未指定，则默认为与x相同*/transform:scaleX(x); /*在X方向上的缩放*/transform:scaleY(y); /*在y方向上的缩放*/ skew 用于倾斜123transform:skew(x,y); /*元素在x轴和y轴方向以指定的角度倾斜，如果y没有指定，则y轴没有倾斜*/transform:skewX(angle); /*绕x轴以指定的角度倾斜*/transform:skewY(angle); /*绕y轴以指定的角度倾斜*/ 我用得最多的就是 rotate，将图像旋转来旋转去的，很容易就达到想要的效果，其次就是translate ，配合animation属性使用，立竿见影。","tags":[{"name":"CSS","slug":"CSS","permalink":"http://famousczm.github.io/tags/CSS/"}]},{"title":"CSS学习小记（一）","date":"2017-04-29T14:39:07.000Z","path":"2017/04/29/CSS学习小记（一）/","text":"user-select属性在浏览一些网站的文章时，读到一些有趣的文字，想把它复制收藏到自己的收藏集中，发现文字不可以选择，也就不可以复制。这种方法可以保护文章版权的效果，虽然花点时间手打也行，不过也是一定程度上保护了文章的传播。 这种效果是怎样实现的呢，用user-select属性就可以实现，在样式中使user-select:none即可使用户不能选择元素中的任何内容，包括文本节点。非常方便，user-select是用来控制内容的可选择性的属性。由于该属性是 CSS3 新增属性，部分浏览器可能不兼容，使用时最好加上各浏览器内核前缀。 嘛~在使用的时候发现了一招瞬间破解这种禁止复制的方法 orz 。对着要复制的文字右键选择 “检查” （我以Chrome为例），弹出开发者控制台，在代码栏中找到 CSS 样式设置，把user-select:none改为user-select:auto，即可启用复制功能。 哈哈，这什么鬼，同样的方法可应用于查看浏览器保存的密码上！一般我们输入账号密码登录某一网站的时候浏览器会提示你是否要保存密码，或者网站上有复选框可以勾选记住密码，这都是利用浏览器的 cookie 来把密码暂存于浏览器中，以便下次登录可以方便点。而那些密码一般都是以黑色圆点方式来显示，但是不要天真地以为这样就看不见密码的内容了。用刚才所说的方法，只要把密码框的type=&quot;password&quot;改为type=&quot;text&quot; 即可将那可悲的密码暴露于艳阳下，一览无遗。 这个故事告诉我们，把密码保存于浏览器中虽然方便，但是也是不安全的。大家请多加注意 visibility属性一直使用display:none来隐藏元素，用得很爽。现在发现还有另一种方法可以实现隐藏元素的效果，使用visibility:hidden就可以了。 那么问题来了，display:none和visibility:hidden究竟有什么样的区别呢，两种完全不一样的东西总有些不同吧。 区别就是： visibility:hidden隐藏元素，但元素所占的空间并不会消失，还会占着位置在那里，犹如一个隐身人，还摸得着。 display:none，则是隐藏元素并不会占位，凭空消失，看不见摸不着，人间蒸发了 网上有人觉得这种用于隐藏元素的属性在浏览器加载脚本时会选择不加载，而到要显示元素时才加载。这种说法我觉得是不正确的，浏览器加载脚本是整个样式文件一起加载进去然后解析显示的，不会在加载前特意分析一遍脚本再选择性加载。 visibility 属性取值为collapse时，表示隐藏表格的一行或者一列，默认值为visible，对所有元素可见 CSS3弹性盒子CSS3 增加了一个新的布局方式：弹性盒子。作用是使得当页面布局必须适应不同的屏幕尺寸和不同的显示设备时，元素可预测地运行。 适应不同屏幕尺寸显示器，这本是另前端开发人员十分苦恼的事情，如今弹性盒子的出现可方便解决这个问题，所以弹性盒子绝对是未来的趋势啊。 声明方法是：1display:flex; 或1display:inline-flex; 使用弹性布局有一个重要的特点是，其子元素的float,clear,vertical-align属性将全部失效。 使用弹性布局的元素被称为 Flex Container（弹性容器），其子元素则被称为 flex item （弹性项目），容器的宽称为 main axis (主轴)，高称为 cross axis （侧轴），每条轴又有起点和终点，花样特别多。 弹性布局有六大属性和它们若干的值： flex-direction属性确定主轴的方向，选择从左开始还是从右开始或是从上开始还是从下开始，默认为 row1flex-direction: row | row-reverse | column | column-reverse; flex-wrap属性排在一条轴线上的项目满了的时候，决定向上排列还是向下排列，默认为 no-wrap1flex-wrap: no-wrap | wrap | wrap-reverse; flex-flow属性这是flex-direction属性和flex-wrap属性的合并，也就是说一次定义两个属性的值，默认值为 row nowrap1flex-flow: &lt;flex-dirwxtion&gt; || &lt;flex-wrap&gt; justify-content属性定义在当前行上主轴的项目该怎么排布，有左对齐、右对齐、居中、两端对齐和每个项目两侧的间隔相等，默认为 flex-start1justify-content: flex-start | flex-end | center | space-between | space-around; align-items属性这个与justify-content相对，是定义在当前行上沿侧轴的项目怎么排布，有上对齐、下对齐、中间对齐、项目第一行文字的基线对齐和如果项目未设置高度或设为auto则占满为容器的高度，默认为 stretch1align-items: flex-start | flex-end | center | baseline | stretch; align-content属性定义多跟轴线的对齐方式，所以只有一根轴线的的话则不起作用1align-content: flex-start | flex-end | center | space-between | space-around | stretch; 以上是容器的属性，还有项目的属性详情可以转战阮一峰老师的博文：Flex 布局教程：语法篇 和实战篇的 Flex 布局教程：实例篇","tags":[{"name":"CSS","slug":"CSS","permalink":"http://famousczm.github.io/tags/CSS/"}]},{"title":"SVG初体验","date":"2017-04-28T03:44:36.000Z","path":"2017/04/28/SVG初体验/","text":"在看一些漂亮的网页时，看到里面有一些漂亮的图形，然而这又不是图片来的，难道是用代码画的？不，是写的？对，把浏览器当成是画布来画画的方法有：Flash， Canvas， SVG 。今天我就探索一下 SVG 的魅力所在，下面图片中的简单图形是用 SVG 画的： 初学div布局的时候也尝试过用div来实现这个图形，但那可真是十分麻烦，不及 SVG 方便。 SVG 有两种表现形式，一种是单独的文件，后缀是.svg，代码按照xml的格式来写，文件可以嵌套到html文件中；另一种是在html中直接使用&lt;svg&gt;标签来写，不过要求html的版本是html5。 SVG 还可以通过JS动态创建并注入到 HTML DOM 中，这样做的优点是，可以根据各个浏览器对 SVG 的兼容性来选择性显示 SVG 。 文件格式的 SVG 也是用&lt;svg&gt;标签创建画布，标签中必须包含version和baseProfile属性，用来确定 SVG 的版本。当然我认为width和height属性也是必要的，怎么也要确定一下画布的大小吧。还有xmln属性（xml namespace）也是必须的。 这里说一下xmln，xml命名空间。之前学 Android 也有这个属性出现，使用 xml命名空间的原因到底是什么，下面引用维基百科的解释： 一个XML文档可能包括来自多个XML词汇表的元素或属性，如果每一个词汇表指派一个命名空间，那么相同名字的元素或属性之间的名称冲突就可以解决。举一个简单的例子来说，在一个订单的XML文档中需要引用到客户和所购买的产品，customer元素和product元素可能都有一个叫做id的子元素。这时候要引用id元素会造成名称冲突，但是如果将两个id元素放到不同的命名空间中就会解决这个问题。 可见是用来解决元素不唯一的问题 实现题图的图形居中显示的过程中，我发现了一种新的居中方法，CSS代码如下：123456margin:auto;position:absolute;top:0;bottom:0;left:0;right:0; 使用绝对定位的方式加上margin:auto就可以了，贼方便。","tags":[{"name":"SVG","slug":"SVG","permalink":"http://famousczm.github.io/tags/SVG/"}]},{"title":"Ubuntu安装软件错误提示","date":"2017-04-21T14:37:02.000Z","path":"2017/04/21/Ubuntu安装软件错误提示/","text":"如图，Ubuntu 上用 apt-get 下载安装 zsh 的时候遇到莫名的错误提示，看错误提示的意识大概就是/var/lib/dpkg/lock这个目录出的问题。网上的说法是，可能有另一个程序正在运行，导致资源被锁不可用。而导致资源被锁的原因可能是上一次运行安装更新时没有正常完成。而我记得上次并没有什么没有正常完成的安装更新，先删除这个目录试试。 解决方法，运行下面命令： 12sudo rm /var/cache/apt/archives/locksudo rm /var/lib/dpkg/lock 又能正常安装更新了","tags":[{"name":"Linux","slug":"Linux","permalink":"http://famousczm.github.io/tags/Linux/"}]},{"title":"JSMin压缩JS文件","date":"2017-04-07T03:30:43.000Z","path":"2017/04/07/JSMin压缩JS文件/","text":"在用 JQuery 或一些其它框架时，总是见到有 min 标记的文件，然后打开里面看代码，结果是一团黑色扭动着蠕虫般的字符密密麻麻地紧挨在一起，瞬间打消我研读的念头。刚开始以为这是防止别人学习抄袭里面的内容，一种版权的控制。到现在我才知道这其实是为了加快脚步的加载速度而把脚本中不必要的空格和注释删除从而达到压缩脚本的效果，也就是精简版本的脚本文件。一般都会把有注释并格式整齐内容清晰的原文件备份，方便以后修改。 当然，制作精简版脚本这种无聊乏味至极的工作肯定不是手工弄的，有几种比较好的工具可以帮助我们，我平时用的是 JSMin ，还有备受好评的 Closure Compiler 。这里我就用 JSMin 来说明如何压缩 JS 。 首先先把这工具给下载下来，进官网拉到最下有下载，点这里 下载完成解压后是一个 .exe 文件。随便放在一个自己喜欢的地方。然后打开控制台，命令格式是：1JSmin.exe的绝对路径 &lt;要压缩的 JS 文件绝对路径&gt;压缩完后的文件名和保存路径 举个例子：1D:\\JS\\jsmin.exe &lt;D:\\JS\\test\\demo.js&gt;D:\\JS\\demo.min.js 就是这样子，打开压缩完的文件，就能看到熟悉的密密麻麻的字符啦","tags":[{"name":"JS","slug":"JS","permalink":"http://famousczm.github.io/tags/JS/"}]},{"title":"JS学习小记（二）","date":"2017-04-06T07:52:06.000Z","path":"2017/04/06/JS学习小记（二）/","text":"获取和替换 p 元素中的文本内容之前学习的 JS 一直都是修改元素的属性内容，样式什么的，其实 JS 也可以修改元素的文本内容。文档树中的节点并不止元素节点一种，还有属性节点和文本节点。所以要获取元素下的文本内容，就要先使用 childNode 属性来获取该元素下的所有子节点信息，然后再使用 nodeValue 属性来获取子节点内容。 这里如果直接用：1p.nodeValue 返回的结果为 null ，因为这里真正需要获得的是 p 元素下的第一个子节点的nodeValue，即 p 元素节点下的文本节点的节点值，而不是 p 元素节点的节点值。所以应该是：1p.childNodes[0].nodeValue chileNodes属性返回的是一个数组。如果 p 下没有其它元素节点的话，那么这个文本节点就是它唯一的子节点，用p.childNodes.length可看出只有一个子节点。 这样整个文档树就没有什么是我 JS 所不能修改的了哈哈 没有块级作用域看《 Javascript 权威指南 》的时候，在讲变量的作用域里看到一个比较有趣的 JS 细节，JS 没有块级作用域。也就是说，只要在函数体内声明的变量，无论在函数体的哪个地方都是有意义的。举例说：1234567891011function test(t)&#123; var i = 0; if(t &gt; 0)&#123; var j = 0; for(var k = 0;k &lt; 10;k++)&#123; console.log(k); &#125; console.log(k); &#125; console.log(j);&#125; 这条程序如果在 jsva 中，肯定后面两个输出是错误的，变量 j 的作用域只是在 if 语句里面，变量 k 的作用域只是在 for 循环里面。然而在 JS 中的运行结果是 照常输出了 还有一种让我吃惊的情况是，如下例子：1234567var scope = &quot;global&quot;;function f()&#123; console.log(scope); var scope = &quot;local&quot;; console.log(scope);&#125;f(); 这个按照我以往的理解，就觉得第一个输出应该是 global 因为这个输出在 scope 重定义之前，然而！结果是： 第一个输出是 undefine 这是因为局部变量在整个函数内都是有定义的，不管它在函数里的哪个地方定义。而在未初始化之前，这个局部变量都是 undefine 也就是说上面的程序相当于：12345678var scope = &quot;global&quot;;function f()&#123; var scope; console.log(scope); scope = &quot;local&quot;; console.log(scope);&#125;f();","tags":[{"name":"JS","slug":"JS","permalink":"http://famousczm.github.io/tags/JS/"}]},{"title":"JS学习小记（一）","date":"2017-04-03T02:53:31.000Z","path":"2017/04/03/JS学习小记（一）/","text":"在学习的过程中总会有一些让我感到惊奇或者以前想不到的东西出现，有时这是另一个庞大复杂的知识体系，有时这只是一个不甚起眼却意义非凡的小知识点。在学习 JS 的过程中，在不断惊叹它的魅力之余，还偶尔学到一些自己觉得很值得记录下来的知识点。 JS 的字符串比较之前学 C++ 和 JAVA ，字符串无论在比较还是传递内容的时候，都是用传址的方法，也就是说字符串是引用类型的，比较字符串是否相等不能直接比较，要用特定的方法或函数来比较，如 JAVA 要用 equals() 方法。 而 JS 的字符串比较是用传值的方法，传递字符串才用传址的方法。如下面的例子：123var s1 = &quot;Welcome&quot;;var s2 = &quot;Wel&quot; + &quot;come&quot;;if(s1 == s2) alert(&quot;s1 and s2 is equals&quot;); 结果返回的是 alert() 中的内容，不愧是 JS 事件处理函数的工作机制事件处理函数也就是 onclick、 onmouseover、 onmouseout等。它们能在特定的事件发生时调用特定的 JS 代码。其工作机制就是：当为某个元素添加了事件处理函数后，当事件发生时，就会调用相应的 JS 代码，这段代码会返回一个布尔值，当布尔值为 true 时，事件处理函数就会认为这个事件发生了，然后进行处理；返回 false 则被认为事件并没有发生。这里有一个非常有代表性的 a 元素，大家都知道，用来生成超链接的，点击跳转相应的页面或者本页的某个地方。我认为 a 标签隐藏了一个 onclick 事件处理函数，所以点击才会有跳转。那可不可以禁止这个超链接的跳转，让它成为一个失活的哑炮超链接呢？如果之前的推论正确，a 元素的超链接是通过 onclick 函数实现的，并且返回 false 就能使 onclick 无效，那么，可以做一下尝试：1&lt;a href=&quot;abc.html&quot; onclick=&quot;return false;&quot;&gt;abc&lt;/a&gt; 然后就发现超链接失效了，点击没跳转，实验成功 严格模式在学习别人的程序的过程中，我发现 JS 开头的地方有这样的语句：1&quot;use strict&quot;; 当时糊里糊涂的，这个像注释一样的是啥玩意？ 原来这就是 “严格模式” 顾名思义，就是让程序变得更严格规范。怎么？原来的 JS 代码松散吗？ 还真的挺松的， 先前被接受的拼写错误将会被认为是异常. JS 被设计为能使新人开发者更易于上手, 所以有时候会给本来错误操作赋予新的不报错误的语义. 有时候这可以解决当前的问题, 但有时候却会给以后留下更大的问题. 严格模式则把这些失误当成错误, 以便可以发现并立即将其改正. 至于严格模式的目的，借用阮一峰老师的话来概括就是： 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。 详细关于 “严格模式” 的解说见阮一峰老师的 Javascript 严格模式详解 总的来说，使用”严格模式”是个好的习惯，也能培养好的习惯 昨天跟朋友去看了《金刚：骷髅岛》 ，想起小时候跟弟弟看的《金刚》，虽然剧情已经不大记得了，但金刚那招牌性的捶胸和怒吼，就倍感熟悉。最后等彩蛋，原来金刚不是那座岛唯一的王，还有许多更强的怪物，其中我好像看到了哥斯拉大王，期待哥斯拉大战金刚","tags":[{"name":"JS","slug":"JS","permalink":"http://famousczm.github.io/tags/JS/"}]},{"title":"cannot read property getContext of null","date":"2017-04-01T08:40:35.000Z","path":"2017/04/01/cannot-read-property-getContext-of-null/","text":"用 JS 在 cavans 上画图的时候，加载页面没有任何效果，调试显示如下错误： 提示 getContext 读不到数据，按理 c 应该存放 canvas 的对象，用： 1console.log(c) 调试返回结果为 null ！这下问题就清晰了，原因是在 HTML 文件中引入 JS 的位置有问题，我这&lt;script&gt;语句放在&lt;head&gt;中，执行JS语句时 canvans 还没有定义，所以读取为 null 。只要将&lt;script&gt;语句放在 canvas 后即可！ 还有一种解决方法是在 JS 文件中把 JS 语句放进这个语句中：123window.onload = function()&#123; /*JS CODE*/&#125; window.onload能等待所有的 html 文件执行完毕再加载函数里的 JS 代码","tags":[{"name":"JS","slug":"JS","permalink":"http://famousczm.github.io/tags/JS/"}]},{"title":"(转)CSS命名规则","date":"2017-03-23T15:02:13.000Z","path":"2017/03/23/转-CSS命名规则/","text":"网上看到这篇关于CSS的命名规则的文章，觉得很有用，就记录下来学习了 关于团队合作的css命名规范 常用的css命名规则头：header 内容：content/container 尾：footer 导航：nav 侧栏：sidebar 栏目：column 页面外围控制整体布局宽度：wrapper 左右中：left right center 登录条：loginbar 标志：logo 广告：banner 页面主体：main 热点：hot 新闻：news 下载：download 子导航：subnav 菜单：menu 子菜单：submenu 搜索：search 友情链接：friendlink 页脚：footer 版权：copyright 滚动：scroll 内容：content 标签页：tab 文章列表：list 提示信息：msg 小技巧：tips 栏目标题：title 加入：joinus 指南：guild 服务：service 注册：regsiter 状态：status 投票：vote 合作伙伴：partner 注释的写法:/ Footer / 内容区 / End Footer / id 的命名:(1)页面结构容器: container 页头：header 内容：content/container 页面主体：main 页尾：footer 导航：nav 侧栏：sidebar 栏目：column 页面外围控制整体布局宽度：wrapper 左右中：left right center (2)导航导航：nav 主导航：mainbav 子导航：subnav 顶导航：topnav 边导航：sidebar 左导航：leftsidebar 右导航：rightsidebar 菜单：menu 子菜单：submenu 标题: title 摘要: summary (3)功能标志：logo 广告：banner 登陆：login 登录条：loginbar 注册：regsiter 搜索：search 功能区：shop 标题：title 加入：joinus 状态：status 按钮：btn 滚动：scroll 标签页：tab 文章列表：list 提示信息：msg 当前的: current 小技巧：tips 图标: icon 注释：note 指南：guild 服务：service 热点：hot 新闻：news 下载：download 投票：vote 合作伙伴：partner 友情链接：link 版权：copyright class的命名:(1)颜色:使用颜色的名称或者16进制代码,如.red { color: red; } .f60 { color: #f60; } .ff8600 { color: #ff8600; } （2）字体大小,直接使用”font+字体大小”作为名称,如.font12px { font-size: 12px; } .font9pt {font-size: 9pt; } (3)对齐样式,使用对齐目标的英文名称,如.left { float:left; } .bottom { float:bottom; } (4)标题栏样式,使用”类别+功能”的方式命名,如.barnews { } .barproduct { } 注意事项:: 1.一律小写; 2.尽量用英文; 3.不加中杠和下划线; 4.尽量不缩写，除非一看就明白的单词. 主要的 master.css 模块 module.css 基本共用 base.css 布局，版面 layout.css 主题 themes.css 专栏 columns.css 文字 font.css 表单 forms.css 补丁 mend.css 打印 print.css zhigang","tags":[{"name":"HTML+CSS","slug":"HTML-CSS","permalink":"http://famousczm.github.io/tags/HTML-CSS/"}]},{"title":"Laravel之Auth数据库连接错误","date":"2017-03-21T03:03:41.000Z","path":"2017/03/21/Laravel之Auth数据库连接错误/","text":"学习 Laravel 不足一天，我就迎来了第二个坑，在 Auth 的登录页面随便输入Email地址和密码后，点击登录，弹出如下错误： 看了一下，勉强知道是数据库连接不上的问题，不过这里出错也是正常的嘛，我又没有配置数据库，还以为 PHP 会内置数据库的我实在是太天真了。那么就赶紧去配置数据库吧。解决方法是： 在 Laravel 的根目录下，打开 .env 文件，修改为自己的数据库设置1234DB_HOST=127.0.0.1DB_DATABASE=laravel5DB_USERNAME=rootDB_PASSWORD=password 我用的是MySQL，我先在MySQL里新创建了一个数据库，命名为laravel5(建议创建一个新数据库，不用添加表，因为后面要迁移Auth的内容到这个数据库内)。然后DB_USERNAME里建议用root登录，DB_PASSWORD为你数据库root的密码，这里一定要填准确。 后面要关闭服务器，并输入：1php artisan make:migration 开始迁移，之后打开 laravel5 数据库，就可以发现有三个新添加的表，包括 user 用户表，然后我们就可以重新打开服务器，愉快地注册登录了，数据自动会保存到 laravel5 数据库中。登录成功的界面如下： 总的来说这个坑不算深，是我自己误踩进去的","tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://famousczm.github.io/tags/Laravel/"}]},{"title":"Linux之sl命令","date":"2017-03-21T02:10:17.000Z","path":"2017/03/21/Linux之sl命令/","text":"Linux中的 ls 命令我们经常使用，这甚至是我使用频率最高的命令。用来查询目录下的子目录或文件，还有查看目录和文件的属性和权限的功能。然而有时有人手快输错了变成 sl （至少我重来没有输错过……），就会出现一个冷冰冰的错误提示，提示这个命令不存在，让人大受打击 因此，sl 就这样应运而生，它的作用是纠正用户的错误习惯，并且还能给用户在黑漆漆的窗口和冷冰冰的代码命令中得到一丝温暖，让人能够会心一笑。不过这需要安装，安装命令：1sudo yum install sl Ubuntu 用户请用1sudo apt-get install sl 然后就是愉快地写错命令了（误ORZ），下面来详细看下sl 的各种用法并与 ls 的对比：1ls 就是显示目录下的文件1sl 巨型D51火车从右到左冒着烟横穿而过，我察觉到输错命令了哈哈 1ls -a 显示目录下所有文件 1sl -a 一场事故似乎发生了，巨型火车上有人发出了help的求救，你会为他/她感到可怜的，因为命令输错了啊 1ls -F 列出文件下的子目录 1sl -F 火车由右下角直奔左上角 1ls -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来。 1sl -l 一辆小型火车呼啸而过 1ls -c 排序文件 1sl -c C51火车取代了原先的D51火车呼啸而过 以上就是sl的全部命令，真是好玩啊，这里再分享一个捉弄人的办法，把系统中的ls命令替换成sl命令：1alias ls=&apos;sl&apos; 简直是恶作剧必备啊哈哈哈改回来用：1alias ls=&apos;ls&apos; 即可 还有我发现一个sl很有趣的地方，就是火车经过的动画不能用ctrl+c来中断，这下更好玩了","tags":[{"name":"Linux","slug":"Linux","permalink":"http://famousczm.github.io/tags/Linux/"}]},{"title":"Laravel初体验","date":"2017-03-20T09:20:40.000Z","path":"2017/03/20/Laravel初体验/","text":"Laravel作为一个框架在PHP界久负盛名，以简洁优雅著称。目前以发布了Laravel 6，但是刚学习还是以较为流行的Laravel 5开始学吧 Laravel 5.0 开始对 PHP版本的要求是要&gt;=5.4，我的是5.6没问题。下载一键安装包并解压到某个文件夹，命令行进入该文件夹，输入：1php artisan serve 出现如下提示：1Laravel development server started on http://localhost:8000/ 并打开浏览器输入地址:localhost:8000，出现题图的界面说明Laravel启动成功 等等！我之前在本机上的Apache端口号是8088，说明这不是运行在Apache上的，这怎么好像Laravel内置了个Web服务器的感觉？？ 其实这的确是使用了其它的服务器，但并不是 Laravel 内置了服务器，而是PHP内置的服务器，PHP从5.4版本以来就内置了一个Web服务器（所以这就是 Laravel 5必须PHP要有5.4版本以上的原因？？）并且Laravel 的 artisan 命令也支持这个内置 web 服务器，所以 Laravel 能运行在内置的服务器里。 内置服务器与传统服务器（Apache/Nginx之流的）的区别是内置服务器不适合用作生产环境中，只能在本地环境中运行和解析PHP代码，而且这也是极其方便，对于在本地上开发网站来说。而且打开内置服务器也十分简单，在当前项目的根目录里输入：1php -S localhost:8000 就可以了，也能正常解析PHP代码，不用为配置Apache或Nginx错误而烦恼不已。 继续扯回 Laravel … artisan 的serve命令还 host 和 port 这两个参数，看名字就知道这是配置主机地址和端口号的，如：1php artisan serve --port=8080 就可以把端口号改为8080了 因为我使用的是一键安装包，项目建在哪里就直接往哪里解压就是了，没有下载安装网上说的 composer （隐约感觉到后面会有一大波错误袭来）。果不其然，使用牛逼哄哄的Auth系统时（Laravel 内置的简单注册登录功能）：1php artisan make:auth 激活Auth（这要先关闭服务器，激活后再打开服务器），界面是出来了，如下： 但是，点击HOME时却弹出这个东西（深感不妙，该来的总会来） 说是什么 Encryption.php 里的 openssl_encrypt() 函数没定义，然后我当然就是去找 Encryption.php 这个文件了，可是不知道是我用一键安装包的原因还是我没仔细找的原因，找了半天都没不知道这个文件躲哪里了。后来另寻它路，把各种安装教程都仔细看一遍，解决方法是： 在PHP的根目录里找到php.ini这个配置文件，打开，在大约893行的位置找到1;extension=php_openssl.dll 并把前面的分号去掉，保存，重启服务器就好了，（nice，问题解决了就兴奋得想大叫） Laravel 先探索到这里，感觉还有很多东西要学的 &gt;__&lt;","tags":[{"name":"Laravel","slug":"Laravel","permalink":"http://famousczm.github.io/tags/Laravel/"}]},{"title":"阿里云学生机硬盘读写速度测试","date":"2017-03-20T06:41:03.000Z","path":"2017/03/20/阿里云学生机硬盘读写速度测试/","text":"看了Linux中国的一篇文章测试服务器的硬盘读写速度，也想试试看阿里云学生机的硬盘读写速度能到什么水平，毕竟是最低配置… 先测试写入速度：1time dd if=/dev/zero of=/var/test bs=2k count=1000000 命令解释： time 用于计时 dd 用于复制，从if读出，写到of if=/dev/zero不产生IO，因此可以用来测试纯写速度；所以后面测试纯读速度，就是 of=/dev/null不产生IO bs是每次读或者写得大小，即一个块的大小，count是读写块的数量，相乘就是读写数据量大小，我这里测试2G数据的写入速度 连续测试三次的结果如下：取平均值就是46.1MB/s了，比Linux中国测试的23.2MB/s几乎快了一倍，所以还是蛮快的，作为WEB服务器已经足够用了 所以同理读速度的测试是1time dd if=/var/test of=/dev/null bs=2k 测试结果为： 平均值为20.6MB/s，可看出，读速度远不如写速度快啊 不过这种低配服务器也只是HDD，不可能是SSD，能用就好 今天天气不错啊，适合出去走走，刚买了域名www.homehouse.tech，关于home的域名大部分都被注册了… 寂寞之时，既想热闹；喧嚣之场，亦思闲静。人情大抵皆然。如猴子在树下，则思量树头果；及在树头，则又思量树下饭。往往复复，略无停刻，良亦苦矣。 节选自《袁宏道集笺校》，卷二十–《兰泽、云泽两叔》","tags":[{"name":"Linux","slug":"Linux","permalink":"http://famousczm.github.io/tags/Linux/"}]},{"title":"Foundation初体验","date":"2017-03-19T13:25:31.000Z","path":"2017/03/19/Foundation初体验/","text":"框架的确是一个很奇妙的玩意，好的框架能让你省时省力，更重要的是它还非常简洁美观易于上手！！Foundation就是这样一个集各种优点在一身的响应式前端开发框架，对于想快速搭建一个漂亮的网站的初学者来说，这无疑是一个能让人赞叹“帮了个大忙”的利器啊（嘛，当然前提是要有最基本的前端知识） Foundation设计好了各种小部件的样式，还有小部件所对应的js控制也做好了，就让我们直接调用就是了。框架就是这么一回事，让开发者集中精力在网站的整体设计和内容上，事半功倍。不过，一直过于依赖框架而从不去了解CSS和js的实现这也是一种停滞不前的做法，我觉得没有对技术的执着追求是不适合干这一行的，程序员不都是这样的一个存在吗？ 目前正在和弟弟一起联手开发咱们自己家的网站，这是我一直以来就非常想实现的一个目标，我打算用Foundation来做，让我见识你的强大之处吧，后台方面决定用laravel，希望一切顺利吧~ (ง๑ •̀_•́)ง","tags":[{"name":"Foundation","slug":"Foundation","permalink":"http://famousczm.github.io/tags/Foundation/"}]},{"title":"服务器上部署网站","date":"2017-03-18T15:39:47.000Z","path":"2017/03/18/服务器上部署网站/","text":"刚学网站开发的时候就很想把自己的作品能发布在网上，能让别人访问到，倍有成就感。但是一直碍于自己的技术还没成熟，想多学学再去想这些事。 现在由于课程的原因，老师要我们租服务器做实验，我也觉得时机已经到了，在阿里云租了台云服务器，学生机最低配置，每月9.9元，相对来说还是挺值得。有点后悔之前没下决心啊。 CentOS6.8系统，内置Oneinstack，开发环境是LNMP，真是省去了不少功夫啊。 用putty远程登录服务器，Linux基础的操作都烂熟于心了。这里还非常感激阿里云提供的帮助手册，帮了大忙，介绍得非常详细 这也是我头一次用Nginx，之前用的都是Apache，Tomcat，IIS啥的，不过服务器在我看来都差不多，除了能解析的后台语言可能有点不太一样，我还重来没有仔细研究它们之间的区别。1cd /etc/nginx/conf.d 进入Nginx的配置文件夹下 1vim default.conf 修改这个默认配置的内容 12345listen 80;#listen [::]:80 default_server;server_name _;root /data/wwwroot/default/海花A620网站-开发中;index A620.html; root 下的路径改为自己的网站文件夹的路径index 下写默认的网站主页 1service nginx restart 重启一下服务器，然后在浏览器中输入IP地址，即可看到自己的网站 关于怎么把本机里的网站文件传送至服务器中，可以用FTP文件传输协议来完成，先在服务器上创建一个FTP账号，Oneinstack在这里发挥了巨大的作用，执行pureftpd_vhost.sh这个文件，可以清晰明了地创建FTP账号并管理它。 创建好FTP账号之后就可以用相关软件来传输文件了，我这里用FlashFXP，添加好服务器地址和FTP账号密码之后，就可以连接上服务器并传输文件了 oneinstack还提供了许多管理工具来使我们能够方便地管理我们的服务器开发环境，如PHP版本切换，JDK版本切换，网站数据迁移至云盘，MySQL数据库管理，管理虚拟主机，管理FTP账号，备份等等。 写完这篇博客已经凌晨十二点半了，洗洗睡吧zZ","tags":[{"name":"Linux","slug":"Linux","permalink":"http://famousczm.github.io/tags/Linux/"}]},{"title":"换电脑后的博客管理","date":"2017-03-18T12:31:05.000Z","path":"2017/03/18/换电脑后的博客管理/","text":"之前硬盘坏了，换硬盘后，一切都是空白，以前所有的设置都没有了，包括这博客的更新。最近查阅了网上的资料，终于可以重新更新了，而且这次也吸收教训，要做好备份。 以前我写完博客deploy到github上，只是把编译后的静态网页给保存了，以至于我clone下来也没什么用。所以这次我新开一个分支用来存放博客的原始文件，另一个分支则用来保存静态网页文件。这样维护起来也简单明了。新分支命名为Hexo。设定为默认分支。 然后在本地新建个文件夹，shift+鼠标右键打开Git Bash输入： 1git clone git@github.com:famousczm/famousczm.github.io.git 拷贝仓库接着在famousczm.github.io.git文件夹下一次执行下面的命令:npm install hexo、hexo init、npm install 和 npm install hexo-deployer-git（由于之前没有备份好，只能重新设置一遍了） 此时，再把之前的博客文章，重新写一次，并转为md文件 新建博客的命令：1hexo new &apos;博客名字&apos; 花了点时间写好，并且重新温习了MarkDown后，可以用下面这个命令： 1hexo g -d 然后打开浏览器，输入http://localhost:4000/，可以看到博客的预览效果 确定无误之后，再配置之前博客的主题，我之前的主题是yilia，十分简洁好看1git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 可能是网络问题，我下了几次都不成功，然后我直接到作者的github下载下来了……并把文件放到themes的yilia文件夹下。 先配置主目录下的主配置文件_config.yml，在最后一行deploy:下加入：123type: gitrepository: https://github.com/famousczm/famousczm.github.iobranch: master 这样编译过后的静态网页就存放在master分支上了 在一次预览一下，跟想象中的一样，这次yilia的作者更新了许多小设置，更好看了，喜欢 喜欢就再依次输入：123git add .git commit -m &quot;...&quot;git push origin hexo 把博客源文件push到Hexo分支上，到这一步我遇到了一个问题：我在git add .的地方出错了错误提示为：1234567891011warning: You ran &apos;git add&apos; with neither &apos;-A (--all)&apos; or &apos;--ignore-removal&apos;,whose behaviour will change in Git 2.0 with respect to paths you removed.Paths like &apos;2016/10/05/Eclispe不能导入java-util-Arrays/index.html&apos; that areremoved from your working tree are ignored with this version of Git.* &apos;git add --ignore-removal &lt;pathspec&gt;&apos;, which is the current default, ignores paths you removed from your working tree.* &apos;git add --all &lt;pathspec&gt;&apos; will let you also record the removals.Run &apos;git status&apos; to check the paths you removed from your working tree. 解决方法： 1git add -A 解决之后，再把静态网页也布置上去1hexo g -d 这里静态网页就去到了master分支了，这是_config.yml的作用，而之前的push到Hexo分支是因为默认分支就是Hexo 到此已经成功将博客部署上去了，这下就可以正常更新博客了 以后的日常更新就是依次执行：1234git add .git commit -m &quot;...&quot;git push origin hexohexo g -d 哪一天电脑又坏了，或者临时要在别的电脑上更博，只需：1git clone git@github.com:famousczm/famousczm.github.io.git 复制这个Hexo分支的源文件下来，再执行：123npm install hexonpm installnpm install hexo-deployer-git 即可，此处不需要执行hexo init，因为基本的文件Hexo里已经保存有了 我又回来了( ◕‿‿◕ )","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://famousczm.github.io/tags/Hexo/"}]},{"title":"JAVA java.io.Writer.write(Unknown Source)","date":"2016-11-05T06:35:51.000Z","path":"2016/11/05/JAVA-java-io-Writer-write-Unknown-Source/","text":"今天在做一个使用JAVA的输入输出流将一个文本文件的内容按行读出，每读出一行就顺序添加行号，并写入到另一个文件中的练习时，写入文件的过程中遇到未知错误如下： 123Exception in thread &quot;main&quot; java.lang.NullPointerException at java.io.Writer.write(Unknown Source) at sy_10.sy10_7.main(sy10_7.java:26) 我程序代码是： 1234567891011121314151617181920212223242526272829303132333435package sy_10;import java.io.*;public class sy10_7 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub File f = new File(&quot;E:\\\\Coder\\\\java\\\\eclipse\\\\test\\\\src\\\\sy_10\\\\Example10_7.java&quot;); File f1 = new File(&quot;E:\\\\Coder\\\\java\\\\eclipse\\\\test\\\\src\\\\sy_10&quot;,&quot;Example10_7.txt&quot;); String s = null; int i = 1; String content[] = new String[50]; try&#123; FileReader inOne = new FileReader(f); BufferedReader inTwo = new BufferedReader(inOne); while((s = inTwo.readLine())!= null)&#123; s = i + &quot;. &quot; + s; content[i-1] = s; i++; System.out.println(s); &#125; inTwo.close(); inOne.close(); FileWriter outOne = new FileWriter(f1); BufferedWriter outTwo = new BufferedWriter(outOne); for(String str:content)&#123; outTwo.write(str); outTwo.newLine(); &#125; outTwo.close(); outOne.close(); &#125; catch(IOException e)&#123; System.out.println(e); &#125; &#125;&#125; 这个错误以前没有遇到过，错误地方就在 1outTwo.write(str); 是写入时有问题，刚开始以为是参数str类型不对，然而并不是，str是String类型没问题，单独输出正常。 网上找了一下，很多说是输入输出流关闭不正确，我想可能是字符流跟缓冲流的关闭顺序不对，把各种顺序都试了一遍，哈！！然而也不是.. 再把写出的操作注释掉，程序正常显示。好吧，把outTwo.write(str);断点然后debug找找原因，在写入时我发现数组content有点异常，初始化时分配了50个数组元素，即表示写入文件时要写入50行，而实际需要写入的只有32行。 把数组元素改为32个时就可以正常写入了….我想这大概是内存溢出导致的异常。具体原因我也不知道。但程序这样写肯定是不行的。因为文件不能总是只有32行吧。 我觉得这应该是数组到了32个元素之后就没有值了，即为null值。所以往文本中写入null值就会出错，这样Unknown Source就可以解释了。所以改了一下写入文本的for循环： 1234567for(String str:content)&#123; if(str == null)&#123; break; &#125; outTwo.write(str); outTwo.newLine(); &#125; 这样之后，把content数组设置为50个元素也不会出错了！！ debug再次救了我","tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://famousczm.github.io/tags/JAVA/"}]},{"title":"Oracle复制另一用户下的表","date":"2016-10-26T06:31:29.000Z","path":"2016/10/26/Oracle复制另一用户下的表/","text":"Oracle下要将用户A里的表T复制给用户B，首先要登陆用户A，用如下语句把查询表T的权限赋给用户B： 1GRANT SELECT ON T TO A; 然后登陆用户B，复制表T并命名为S： 1CREATE TABLE S AS SELECT * FROM A.T; 这样就可以了（表名前一定要加上模式名）","tags":[{"name":"Oracle","slug":"Oracle","permalink":"http://famousczm.github.io/tags/Oracle/"}]},{"title":"PHP字符编码","date":"2016-10-18T06:31:12.000Z","path":"2016/10/18/PHP字符编码/","text":"昨天用PHP做项目的时候遇到了浏览器字符编码的问题，用Chrome和FF来做测试。本想着改浏览器网页显示的字符编码就可以了，结果一刷新或重新打开就又乱码了。解决方法是设置要浏览器的默认字符编码 Chrome很简单，打开设置-&gt;显示高级设置-&gt;网络内容-&gt;自定义字体-&gt;编码，设置为UTF-8即可 FireFox的49.01版设置不了UTF-8编码，只有各种语言的选择。只能用alt弹出隐藏的菜单栏，在查看那里设置文字编码，不过这不是默认的，刷新就又重置了。 所以以上都不是办法，别人访问你的网站可不能要让别人要先设置默认的字符编码才能看到中文啊。真正的方法是在PHP中设置meta标签 在html的head标签里加上： 1&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; 即可。我写PHP是用Zend Studio，新建PHP文件的时候没有xml的模板，在Windows-&gt;Preferences-&gt;PHP-&gt;Editor-&gt;Templates中新建一个也不行。解决方法是替换原来的html4.01的模板，Windows-&gt;Preferences-&gt;PHP-&gt;Code Style-&gt;Code Templates-&gt;Code,选中html4.01frameset然后编辑把xml的模板替换原来的模板。到这里还没有完成，因为Zend Studio还没有将charset设置的值转化。 继续设置Generate-&gt;WorkSpace,把Text file encoding勾选other选中UTF-8就可以了 今天大雨。","tags":[{"name":"PHP","slug":"PHP","permalink":"http://famousczm.github.io/tags/PHP/"}]},{"title":"树莓派初体验","date":"2016-10-12T06:13:29.000Z","path":"2016/10/12/树莓派初体验/","text":"上课的时候突然想买个树莓派来玩玩，就马上入手了Raspberry Pi3 B+，等了三天，今天终于来了。这玩意看似便宜，其实为了能真正使用它，还要配备其它器件啊。我顺带买了32G的内存卡（树莓派要外带硬盘），电源适配器（Pi3要求有5V，2.5A的电源，懒得找，就买了）还有个官方外壳（保护作用，没错，树莓派来的时候是裸着的）。本来还需要个显示器的，因为树莓派的视频接口是HDMI，很遗憾我宿舍没有电视机，台式显示屏倒是有一个，可是我忘了买转VGA的转换器，而且人家也要用。所以就按照网上说的用笔记本远程连接咯。于是我又买了路由器，两条网线。一切准备就绪！ 首先，格式化并烧录SD卡，格式化的时候系统提示磁盘写保护，不能写入数据也不能格式化。把读卡器的LOCK来回拨了几次，修改注册表也不行。其实是读卡器的问题，换一个就好了 用软件Win32DiskImager把下载好的2016-05-10-raspbian-jessie.img镜像烧录进SD卡，几分钟就完事了 把内存卡插进树莓派，接上电源，用网线连上路由器。打开软件advanced_ip_scanner，检索树莓派的IP地址 再用putty输入IP，端口22连接。默认用户名：pi 密码：raspberry 登陆进之后，输入命令： 1sudo raspi-config 进入配置界面 这里我选第一个扩展SD空间，因为树莓派安装完成后只用了部分SD卡的空间，所以不浪费资源，就扩展SD空间咯。另外我还改了登陆密码，其它就先不管它。 接下来进行基础配置。添加国内的软件源，因为树莓派默认的服务器比较慢 1sudo vi /etc/apt/sources.list 把里面的内容删了，复制粘贴下面的内容 12deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ wheezy main non-free contribdeb-src http://mirrors.ustc.edu.cn/raspbian/raspbian/ wheezy main non-free contrib 保存退出，运行 1sudo apt-get update 配置一个静态地址，现在的ip地址是自动分配的，每次登陆都不相同，找ip地址也会费一些功夫，所以设置一个固定的地址方便以后登陆。 1sudo vi /etc/network/interfaces 找到iface eth0 inet manual，改为 123iface eth0 inet staticaddress 192.168.1.102netmask 255.255.255.0 保存退出，重启网络 1sudo /etc/init.d/networking restart 为了能操作树莓派的界面，我用VNC来远程登陆，首先添加安装vnc server 1sudo apt-get install tightvncserver 运行tightvncserver 1tightvncserver 这时会要求输入几次密码，网上说这是控制密码，然后选择性输入查看密码，查看密码只能用来查看桌面，而控制密码才能对桌面进行操作。 然后下载VNC软件安装后，输入ip地址：端口号（1,2,3都可以），端口号不同区分不同的用户 连接后要求输入树莓派密码，输入后就能登陆树莓派操作界面了，尝试上网，能行。发现树莓派这个Liunx系统默认安装python2和3啊，以后编程还是以python为主了。 最后就是如何关闭树莓派了，树莓派插上电源就自动开机，关闭它当然不是直接拔开，这算非正常断电，很容易损坏树莓派，正确方法是 1sudo shutdown -h now(或其它一切关机的命令) 然后知道黄色的指示灯不闪了，只剩红色的电源指示灯，这时就表明树莓派已经关机了，然后就可以拔电源了","tags":[{"name":"树莓派","slug":"树莓派","permalink":"http://famousczm.github.io/tags/树莓派/"}]},{"title":"Linux添加磁盘","date":"2016-10-08T06:13:13.000Z","path":"2016/10/08/Linux添加磁盘/","text":"今天学习了Linux关于磁盘的知识，以添加磁盘为例总结一下： 我用的是VirtualBox虚拟机，先关掉Linux，然后在VBox的设置-&gt;存储-&gt;控制器，右键添加虚拟硬盘-&gt;选创建一个新的虚拟盘-&gt;选VDI-&gt;动态分配-&gt;然后就分配自己想要的磁盘大小，不过要在分配的那个盘所接受的范围内就行。 创建好后，运行Linux。 为新添加的磁盘分区。用管理员权限输入命令 1fdisk -l 查看目前磁盘信息，看到1Disk /dev/sdb: 8589 MB, 8589934592 bytes 这一行信息中的/dev/sdb就是新添加的磁盘了（不知道是不是都是叫sdb的…检查一下大小与自己划分的一样就是了，这里我用了默认的8G） 确认好新增的磁盘后，再输入： 1fdisk /dev/sdb 进入分区模式，这里有一堆命令可操作，用常见的’p’查看当前磁盘的分区情况、’n’建立一个新分区和’d’删除一个分区，这几个命令即可。输入p，可以看见磁盘sdb并没有被分过区 再输入n，开始分区，可以选择’e’扩展分区，’p’主分区，之前看鸟哥的教程时看得糊里糊涂，实操之后就知道是怎么回事了，总共可以分4个分区，可以是四个主分区，但是如果想要分不止四个分区的话，就要用扩展分区了，可以三个主分区+一个扩展分区，然后再从扩展分区里划分逻辑分区，前三个主分区的标识是sdb1，sdb2，sdb3，扩展分区是sdb4，逻辑分区是由sdb5开始一直推算下去的。这里无论前面四个分区怎么设置，只划分一个也好，逻辑分区都是从sdb5开始的。还有一点必须要注意的是，划分了扩展分区后，剩下的只能从扩展分区中划分逻辑分区了，不管你之前的空间有没有分配完，所以一般主分区划分完后，剩下的所有空间一股脑的全塞给扩展分区就对了，不要省着，省着就是浪费了。 不小心分错了也不要紧张，因为还没有保存，可以用ctrl+c快速退出，再重新分区，所以可以好好研究研究一下吧，不过怎么说分区都是个高危工作，如果磁盘里有重要资料的话还是小心一点为妙。 格式化磁盘。分好区后，输入命令： 1mke2fs -t ext4 -L TEST /dev/sdb5 我系统是CentOS6.5，所以文件系统用的是ext4，设置了标签TEST 挂载磁盘。磁盘要挂载在一个目录中，才能使用这个磁盘，但是如果一个目录原先有文件存在的话，挂载磁盘后所有数据将会被覆盖，消失了。卸载磁盘后才可以看到。就是这么回事，所以就要找个空目录来挂载咯。 我在根目录下新建一个目录newdir，输入命令： 1mount /dev/sdb5 /newdir/ 再看看磁盘信息 1df -h 显示信息，挂载成功 123456[root@localhost user1]# df -hFilesystem Size Used Avail Use% Mounted on/dev/mapper/VolGroup-lv_root 7.5G 738M 6.4G 11% /tmpfs 250M 0 250M 0% /dev/shm/dev/sda1 485M 31M 429M 7% /boot/dev/sdb5 989M 18M 921M 2% /newdir 设置开机挂载。在文件/etc/fstab最后一行，添加我新磁盘sdb5的信息 1LABEL=TEST /newdir ext4 defaults 0 0 保存退出，设置完成 不懂的地方还是有很多，不过思路总算明朗了一点，最后想说的是LABEL经常打错成LABLE啊啊啊，导致好几次运行出错，英语也要好好学啊，切记切记…","tags":[{"name":"Linux","slug":"Linux","permalink":"http://famousczm.github.io/tags/Linux/"}]},{"title":"Linux的目录","date":"2016-10-06T06:00:42.000Z","path":"2016/10/06/Linux的目录/","text":"学习Linux中，很多操作和设置都要涉及各个目录，所以认识明白Linux各个目录的作用非常重要，而且我为了省内存没有安装图形界面(:з」∠)于是就在网上找来了关于linux目录的资料来学习学习啦。 首先“/”代表了linux的根目录，就相当于树根一样。在linux系统中文 根文件系统，linux所有的一切全部在这里面存放着。 /bin：（binary）用来存放二进制可执行的命令，包含了普通用户可能用到的命令，这些命令都是二进制文件。/usr/bin在此目录下也可存放二进制命令 /home 这个目录就不用说了，就是存放用户的目录。系统里新建一个用户就会在/home目录下为用户创建一个目录。 /sbin：目录类似/bin也是用于存储二进制文件，非普通用户所使用的命令，大多为系统管理员使用的基本的系统程序。 /etc：目录存放着各种系统配置文件，一些应用程序服务配置文件，用户和组信息文件（/etc/passwd 和/etc/group）linux也正是由这些文件才得以正常地运行。 /root: 是超级用户的目录。 /lib：目录是根文件系统上的程序所需的共享库，存放了根文件系统程序运行所需的共享文 件。这些文件包含了可被许多程序共享的代码，以避免每个程序都包含有相同的子程序的副 本，故可以使得可执行文件变得更小，节省空间。 在/lib/modules目录包含系统核心可加载各种模块，尤其是那些在恢复损坏的系统时重新引导系统所需的模块(例如网络和文件系统驱动)。 /dev目录存放了设备文件，即设备驱动程序，用户通过这些文件访问外部设备。比如，用 户可以通过访问/dev/mouse来访问鼠标的输入，就像访问其他文件一样。 /tmp目录存放程序的运行是的缓存信息和数据，但在引导启动后，运行程序最好使用/var/tmp来代替/tmp，因为/var/tmp可能拥有更大的磁盘空间，分区时一般会把/var单独挂到一个磁盘上。 /boot 目录存放的引导加载器使用的文件，核心映像也经常放在这里，而不是放在根目录中。但是如果有许多核心映像，这个目录就可能变得很大，这时使用单独的 文件系统会更好一些。还有一点要注意的是，要确保核心映像必须在IDE硬盘的前1024柱面内。 /mnt 目录是系统管理员临时安装挂载（mount）文件系统的安装点。系统并不自动支持安装到/mnt。/mnt 下面可以分为许多子目录，例如/mnt/dosa 可能是使用msdos文件系统的软驱，而/mnt/exta 可能是使用ext2文件系统的软驱，/mnt/cdrom 光驱等等。 /var 包含系统一般运行时要改变的数据。通常这些数据所在的目录的大小是要经常变化 或扩充的。原来/var目录中有些内容是在/usr中的，但为了保持/usr目录的相对稳定，就把那 些需要经常改变的目录放到/var中了，各种服务的日志信息。 /usr 是个很重要的目录，通常这一文件系统很大，因为所有程序安装在这里。/usr 里的 所有文件一般来自linux发行版(distribution)；本地安装的程序和其他东西在/usr/local 下，因为这样可以在升级新版系统或新发行版时无须重新安装全部程序。/usr 目录下的许多内容是 可选的，但这些功能会使用户使用系统更加有效。/usr可容纳许多大型的软件包和它们的配置 文件。 /proc文件系统/proc 文件系统是一个伪的文件系统，就是说它是一个实际上不存在的目录，因而这是一 个非 常特殊的目录。它并不存在于某个磁盘上，而是由核心在内存中产生。这个目录用于提供关于系 统的信息。 这趟水还真深","tags":[{"name":"Linux","slug":"Linux","permalink":"http://famousczm.github.io/tags/Linux/"}]},{"title":"Hexo的评论功能","date":"2016-10-06T05:58:51.000Z","path":"2016/10/06/Hexo的评论功能/","text":"换了Litten的yilias主题，简洁、舒服，深得我心。然后在多说创建了站点为博客设置评论的功能。多说能够使用户方便地在后台管理留言，嗯，看起来还是很好用的（如果留言人数多的话） 复制多说提供的代码，打开themes/yilias/layout/_partial/下的文件article.ejs，把最后一段: 1234&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.duoshuo_shortname)&#123; %&gt; &lt;section id=&quot;comments&quot;&gt; &lt;/section&gt;&lt;% &#125; %&gt; 替换成1234567891011121314151617181920&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.duoshuo_shortname)&#123; %&gt; &lt;section id=&quot;comments&quot;&gt; &lt;!-- 多说评论框 start --&gt; &lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;&quot; data-title=&quot;&lt;%= post.title %&gt;&quot; data-url=&quot;&lt;%= page.permalink %&gt;&quot;&gt;&lt;/div&gt; &lt;!-- 多说评论框 end --&gt; &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt; &lt;script type=&quot;text/javascript&quot;&gt; var duoshuoQuery = &#123;short_name:&quot;famousczm&quot;&#125;; (function() &#123; var ds = document.createElement(&apos;script&apos;); ds.type = &apos;text/javascript&apos;;ds.async = true; ds.src = (document.location.protocol == &apos;https:&apos; ? &apos;https:&apos; : &apos;http:&apos;) + &apos;//static.duoshuo.com/embed.js&apos;; ds.charset = &apos;UTF-8&apos;; (document.getElementsByTagName(&apos;head&apos;)[0] || document.getElementsByTagName(&apos;body&apos;)[0]).appendChild(ds); &#125;)(); &lt;/script&gt; &lt;!-- 多说公共JS代码 end --&gt; &lt;/section&gt;&lt;% &#125; %&gt; 注意：short_name: 后面要填自己站点的short_name，即在创建站点时的站点名称 保存后，打开站点配置文件_config.yml，在最后一行写上： 1duoshuo_shortname: famousczm（自己的short_name） 完成这些后，我发现博客虽然已经有了评论功能，但是不单单每篇文章下有评论，主页上用来预览的文章下也堆满评论，这很傻啊！找了很久原因，才发现是主题配置文件_config.yml忘记设置了，只要把duoshuo改成这样就好了 1duoshuo: &quot;famousczm&quot;","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://famousczm.github.io/tags/Hexo/"}]},{"title":"Eclispe不能导入java.util.Arrays","date":"2016-10-05T05:55:11.000Z","path":"2016/10/05/Eclispe不能导入java-util-Arrays/","text":"做练习的时候，出现了不能导入java.util.Arrays的问题，找来两大java高手（反正java方面比我厉害）来研究了很久都没法解决。 这个问题看起来的确很诡异，Arrays类确确实实存在着，能找到，其它类也能导入，但就是没办法导入这个。网上众说纷纷，都是没有什么好解决方法。 今天把JDK1.8换成了1.7，就成功了，看来确实是版本的问题，据说是JDK1.8太新了，不太稳定。而且顺带发现并解决了在命令行中无法编译java文件的问题 ，原因是安装JDK和jre的过程中，不能放在同一文件夹下，会有冲突。 这下可以继续做作业了。","tags":[{"name":"Java","slug":"Java","permalink":"http://famousczm.github.io/tags/Java/"}]},{"title":"Hexo中文乱码","date":"2016-10-05T05:52:43.000Z","path":"2016/10/05/Hexo中文乱码/","text":"用Hexo搭建的博客title默认为Hexo，我想修改为自己设置的值。于是在public文件夹下的index.html中修改title的值，可是重新生成静态文件时一切又恢复为默认值Hexo。 原因是每次更新博客时都是在Git Shell中清除缓存文件和已生成的静态文件，然后再重新生成新的静态文件。最后deploy到github上，所以原来的index.html文件已经被毁灭了再生成，原先的设置也不复存在了 这要在文件_config.yml中修改title的值，把 title： Hexo 修改为 title: 柱铭（填要修改的值） 即可，要注意的是，：后面要空一个格 到这里重新部署时，网页的title出现乱码 解决方法： 把_config.yml文件编码成UTF-8即可 我用Notepad++的操作是：格式-&gt;转为UTF-8编码格式-&gt;保存","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://famousczm.github.io/tags/Hexo/"}]},{"title":"第一篇博客","date":"2016-10-05T05:46:02.000Z","path":"2016/10/05/第一篇博客/","text":"Markdown 是一种用来写作的轻量级「标记语言」，即跟HTML差不多，不过更为简洁和高效。使用的标签既简单又少，很容易就能记住了，而且Markdown相比格式更注重内容，所以写起来并不麻烦。文件后缀为md，因为在Github里要用到这个标记语言，所以就技多不压身地学习了咯 这是我的第一篇博客，有点简陋","tags":[{"name":"学习心得","slug":"学习心得","permalink":"http://famousczm.github.io/tags/学习心得/"}]}]